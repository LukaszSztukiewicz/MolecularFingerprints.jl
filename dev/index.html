<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MolecularFingerprints.jl</title><meta name="title" content="Home · MolecularFingerprints.jl"/><meta property="og:title" content="Home · MolecularFingerprints.jl"/><meta property="twitter:title" content="Home · MolecularFingerprints.jl"/><meta name="description" content="Documentation for MolecularFingerprints.jl."/><meta property="og:description" content="Documentation for MolecularFingerprints.jl."/><meta property="twitter:description" content="Documentation for MolecularFingerprints.jl."/><meta property="og:url" content="https://LukaszSztukiewicz.github.io/MolecularFingerprints.jl/"/><meta property="twitter:url" content="https://LukaszSztukiewicz.github.io/MolecularFingerprints.jl/"/><link rel="canonical" href="https://LukaszSztukiewicz.github.io/MolecularFingerprints.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MolecularFingerprints.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><a class="tocitem" href="getting_started/">Getting Started</a></li><li><a class="tocitem" href="documentation/">Documentation</a></li><li><a class="tocitem" href="testing/">Testing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MolecularFingerprints"><a class="docs-heading-anchor" href="#MolecularFingerprints">MolecularFingerprints</a><a id="MolecularFingerprints-1"></a><a class="docs-heading-anchor-permalink" href="#MolecularFingerprints" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl">MolecularFingerprints</a>.</p><ul><li><a href="#MolecularFingerprints.AccumTuple"><code>MolecularFingerprints.AccumTuple</code></a></li><li><a href="#MolecularFingerprints.ECFP"><code>MolecularFingerprints.ECFP</code></a></li><li><a href="#MolecularFingerprints.MHFP"><code>MolecularFingerprints.MHFP</code></a></li><li><a href="#MolecularFingerprints.MorganAtomEnv"><code>MolecularFingerprints.MorganAtomEnv</code></a></li><li><a href="#Base.isless-Tuple{MolecularFingerprints.AccumTuple, MolecularFingerprints.AccumTuple}"><code>Base.isless</code></a></li><li><a href="#MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}"><code>MolecularFingerprints.ecfp_atom_invariant</code></a></li><li><a href="#MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}"><code>MolecularFingerprints.ecfp_hash</code></a></li><li><a href="#MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}"><code>MolecularFingerprints.ecfp_hash_combine</code></a></li><li><a href="#MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, MHFP}"><code>MolecularFingerprints.fingerprint</code></a></li><li><a href="#MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, TopologicalTorsion}"><code>MolecularFingerprints.fingerprint</code></a></li><li><a href="#MolecularFingerprints.fingerprint-Union{Tuple{N}, Tuple{MolecularGraph.SMILESMolGraph, ECFP{N}}} where N"><code>MolecularFingerprints.fingerprint</code></a></li><li><a href="#MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}"><code>MolecularFingerprints.getAtomCode</code></a></li><li><a href="#MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getPathsOfLengthN</code></a></li><li><a href="#MolecularFingerprints.getTTFPCode-Tuple{Vector}"><code>MolecularFingerprints.getTTFPCode</code></a></li><li><a href="#MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getTopologicalTorsionFP</code></a></li><li><a href="#MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.SMILESMolGraph}"><code>MolecularFingerprints.get_atom_invariants</code></a></li><li><a href="#MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.SMILESMolGraph}"><code>MolecularFingerprints.get_bond_invariants</code></a></li><li><a href="#MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}"><code>MolecularFingerprints.mhfp_hash_from_molecular_shingling</code></a></li><li><a href="#MolecularFingerprints.mhfp_shingling_from_mol"><code>MolecularFingerprints.mhfp_shingling_from_mol</code></a></li><li><a href="#MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}"><code>MolecularFingerprints.rdkit_bond_type</code></a></li><li><a href="#MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_atoms</code></a></li><li><a href="#MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}"><code>MolecularFingerprints.smiles_from_circular_substructures</code></a></li><li><a href="#MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_rings</code></a></li><li><a href="#MolecularFingerprints.tanimoto-Tuple{BitVector, BitVector}"><code>MolecularFingerprints.tanimoto</code></a></li></ul><article><details class="docstring" open="true"><summary id="MolecularFingerprints.AccumTuple"><a class="docstring-binding" href="#MolecularFingerprints.AccumTuple"><code>MolecularFingerprints.AccumTuple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AccumTuple</code></pre><p>Internal structure for tracking and comparing atomic neighborhoods during ECFP generation.</p><p>Used to detect duplicate neighborhoods and maintain consistency with RDKit&#39;s algorithm by storing bond connectivity patterns along with invariant hashes.</p><p><strong>Fields</strong></p><ul><li><code>bits::BitVector</code>: Bit representation of the bond neighborhood</li><li><code>invariant::UInt32</code>: Hash invariant for this neighborhood</li><li><code>atom_index::Int</code>: Index of the central atom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L189-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ECFP"><a class="docstring-binding" href="#MolecularFingerprints.ECFP"><code>MolecularFingerprints.ECFP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ECFP{N} &lt;: AbstractFingerprint</code></pre><p>Extended-Connectivity Fingerprint (ECFP) calculator.</p><p>ECFPs are circular fingerprints encoding a local molecular environment around each atom up to a specified radius. This implementation closely follows the RDKit algorithm.</p><p><strong>Fields</strong></p><ul><li><code>radius::Int</code>: The maximum number of bonds to traverse from each atom (default: 2)</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: The size of the fingerprint bit vector</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create ECFP4 (radius=2) with 2048 bits
fp_calc = ECFP{2048}(2)

# Create ECFP6 (radius=3) with 1024 bits
fp_calc = ECFP{1024}(3)</code></pre><p><strong>References</strong></p><p>Rogers, D., &amp; Hahn, M. (2010). Extended-connectivity fingerprints. Journal of Chemical Information and Modeling, 50(5), 742-754.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L3-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.MHFP"><a class="docstring-binding" href="#MolecularFingerprints.MHFP"><code>MolecularFingerprints.MHFP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MHFP</code></pre><p>Class for MHFP fingerprint generator/featurizer. Contains settings and parameters for  MHFP fingerprint generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L7-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.MorganAtomEnv"><a class="docstring-binding" href="#MolecularFingerprints.MorganAtomEnv"><code>MolecularFingerprints.MorganAtomEnv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MorganAtomEnv</code></pre><p>Internal structure representing a Morgan atom environment.</p><p>Stores the hash code, atom identifier (index), and layer/radius for each atomic environment encountered during ECFP fingerprint generation.</p><p><strong>Fields</strong></p><ul><li><code>code::UInt32</code>: Hash code representing the atomic environment</li><li><code>atom_id::Int</code>: Identifier of the central atom</li><li><code>layer::Int</code>: Radius/layer at which this environment was computed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L168-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Tuple{MolecularFingerprints.AccumTuple, MolecularFingerprints.AccumTuple}"><a class="docstring-binding" href="#Base.isless-Tuple{MolecularFingerprints.AccumTuple, MolecularFingerprints.AccumTuple}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(a::AccumTuple, b::AccumTuple)</code></pre><p>Define ordering for AccumTuple objects to match RDKit&#39;s sorting behavior.</p><p>Compares AccumTuples by first checking the bit vectors in reverse order (matching boost::dynamic_bitset comparison), then by invariant value, then by atom index.</p><p><strong>Arguments</strong></p><ul><li><code>a::AccumTuple</code>: First tuple to compare</li><li><code>b::AccumTuple</code>: Second tuple to compare</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: true if a &lt; b according to the defined ordering</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L210-L224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}"><a class="docstring-binding" href="#MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}"><code>MolecularFingerprints.ecfp_atom_invariant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ecfp_atom_invariant(smiles::AbstractString)
ecfp_atom_invariant(mol::AbstractMolGraph)
ecfp_atom_invariant(mol::AbstractMolGraph, atom_index)</code></pre><p>Calculate atomic invariants for ECFP fingerprint generation.</p><p>The atomic invariants are properties of an atom that don&#39;t depend on initial atom numbering, based on the Daylight atomic invariants. This implementation follows the RDKit approach.</p><p><strong>Arguments</strong></p><ul><li><code>smiles::AbstractString</code>: SMILES string representation of a molecule</li><li><code>mol::AbstractMolGraph</code>: Molecular graph structure</li><li><code>atom_index</code>: Index of the specific atom to compute invariants for. If not specified, invariants for all atoms are computed and returned</li></ul><p><strong>Returns</strong></p><ul><li>For single atom: <code>Vector{UInt32}</code> containing the invariant components</li><li>For all atoms: <code>Vector{Vector{UInt32}}</code> with invariants for each atom</li></ul><p><strong>Invariant Components</strong></p><p>The computed invariants include (in order):</p><ol><li>Atomic number</li><li>Total degree (number of neighbors including implicit hydrogens)</li><li>Total number of hydrogens (implicit + explicit)</li><li>Atomic charge</li><li>Delta mass (difference from standard isotope mass)</li><li>Ring membership indicator (1 if atom is in a ring, omitted otherwise)</li></ol><p><strong>References</strong></p><p>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/FingerprintUtil.cpp#L244</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L40-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}"><a class="docstring-binding" href="#MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}"><code>MolecularFingerprints.ecfp_hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ecfp_hash(v::Vector{UInt32})</code></pre><p>Generate a hash value from a vector of UInt32 values.</p><p>Iteratively combines all values in the vector using the ECFP hash combining algorithm to produce a single hash value representing the entire vector.</p><p><strong>Arguments</strong></p><ul><li><code>v::Vector{UInt32}</code>: Vector of values to hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt32</code>: Hash value representing the input vector</li></ul><p><strong>References</strong></p><p>Boost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/RDGeneral/hash/hash.hpp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L143-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}"><a class="docstring-binding" href="#MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}"><code>MolecularFingerprints.ecfp_hash_combine</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ecfp_hash_combine(seed::UInt32, value::UInt32)</code></pre><p>Combine two hash values using the boost hash_combine algorithm.</p><p>This function implements the hash combining strategy used in RDKit&#39;s ECFP implementation, which is based on the boost C++ library&#39;s hash_combine function.</p><p><strong>Arguments</strong></p><ul><li><code>seed::UInt32</code>: Current hash seed value</li><li><code>value::UInt32</code>: New value to combine into the hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt32</code>: Combined hash value</li></ul><p><strong>References</strong></p><p>Boost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/RDGeneral/hash/hash.hpp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L121-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, MHFP}"><a class="docstring-binding" href="#MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, MHFP}"><code>MolecularFingerprints.fingerprint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fingerprint(mol::SMILESMolGraph, calc::MHFP{N})</code></pre><p>Calculates the MHFP fingerprint of the given molecule and returns it as a bit vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L106-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, TopologicalTorsion}"><a class="docstring-binding" href="#MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, TopologicalTorsion}"><code>MolecularFingerprints.fingerprint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fingerprint(mol::Graph, calc::TopologicalTorsion)</code></pre><p>Returns a topological torsion fingerprint as an integer vector for the molecule belonging to mol.  This function calls function which computes the Topological Torsion fingerprint based on the molecular structure using paths of length pathLength.</p><p><strong>Arguments</strong></p><ul><li><code>mol::Graph</code>: the molecule for which to calculate the fingerprint</li><li><code>calc::TopologicalTorsion</code>: struct containing parameters for fingerprint computation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/torsions.jl#L24-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.fingerprint-Union{Tuple{N}, Tuple{MolecularGraph.SMILESMolGraph, ECFP{N}}} where N"><a class="docstring-binding" href="#MolecularFingerprints.fingerprint-Union{Tuple{N}, Tuple{MolecularGraph.SMILESMolGraph, ECFP{N}}} where N"><code>MolecularFingerprints.fingerprint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fingerprint(mol::SMILESMolGraph, calc::ECFP{N}) where N</code></pre><p>Generate an ECFP (Extended-Connectivity Fingerprint) for a molecule.</p><p>This function implements the Morgan/ECFP algorithm as described in the original paper and matching the RDKit implementation. It generates circular fingerprints by iteratively expanding atomic neighborhoods up to the specified radius.</p><p><strong>Algorithm Overview</strong></p><ol><li>Compute initial atom invariants (layer 0)</li><li>For each layer up to the specified radius:<ul><li>Expand atomic neighborhoods by one bond</li><li>Hash neighborhood information to create new invariants</li><li>Detect and eliminate duplicate neighborhoods</li><li>Store unique atomic environments</li></ul></li><li>Map all environment hashes to bit positions in the fingerprint</li></ol><p><strong>Arguments</strong></p><ul><li><code>mol::SMILESMolGraph</code>: Input molecular graph</li><li><code>calc::ECFP{N}</code>: ECFP calculator specifying radius and fingerprint size</li></ul><p><strong>Returns</strong></p><ul><li><code>BitVector</code>: Binary fingerprint of length N with bits set for detected molecular features</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mol = smilestomol(&quot;CCO&quot;)  # Ethanol
fp_calc = ECFP{2048}(2)   # ECFP4 with 2048 bits
fp = fingerprint(mol, fp_calc)</code></pre><p><strong>References</strong></p><ul><li>Rogers, D., &amp; Hahn, M. (2010). Extended-connectivity fingerprints. J. Chem. Inf. Model., 50(5), 742-754.</li><li>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L257</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L317-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}"><code>MolecularFingerprints.getAtomCode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getAtomCode(degree::Int, piBond::Int, atomicNumber::Int)</code></pre><p>Calculates an integer for an atom of a molecule from number of non-hydrogen branches, number of pi bonds and atomic number</p><p><strong>Arguments</strong></p><ul><li><code>degree::Int</code>: number of non-hydrogen branches</li><li><code>piBond::Int</code>: number of pi bonds</li><li><code>atomicNumber::Int</code>: atomic number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/torsions.jl#L207-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getPathsOfLengthN</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getPathsOfLengthN(mol::Graph, N::Int)</code></pre><p>Returns a list of all simple paths of length N and cycles of length N - 1 in the Molecular Graph.</p><p><strong>Arguments</strong></p><ul><li><code>mol::Graph</code>: the molecule from which to extract the walks</li><li><code>N::Int</code>: length of the walks, meaning number of vertices in walk</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/torsions.jl#L99-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getTTFPCode-Tuple{Vector}"><a class="docstring-binding" href="#MolecularFingerprints.getTTFPCode-Tuple{Vector}"><code>MolecularFingerprints.getTTFPCode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getTTFPCode(pathCodes::Vector)</code></pre><p>Calculates the fragments which will build the topological torsion fingerprint from the atom codes of each path.</p><p><strong>Arguments</strong></p><ul><li><code>pathCodes::Vector</code>: contains all atom codes of all N-paths and cyclesS</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/torsions.jl#L169-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getTopologicalTorsionFP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getTopologicalTorsionFP(mol::Graph)</code></pre><p>Returns the Topological Torsion Fingerprint of a molecule as an Int Vector. This function loops over all simple paths of length pathLength and all cycle of length pathLength - 1 of the molecular graph,  and gets a number for each atom in a path, an &quot;Atom Code&quot; from which an IntVector is calculated.</p><p><strong>Arguments</strong></p><ul><li><code>mol::Graph</code>: the molecule for which to calculate the fingerprint</li><li><code>pathLength::Int</code>: length of walks from molecular graph used to calculated fingerprint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/torsions.jl#L40-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.SMILESMolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.SMILESMolGraph}"><code>MolecularFingerprints.get_atom_invariants</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_atom_invariants(mol::SMILESMolGraph)</code></pre><p>Compute hashed atom invariants for all atoms in a molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::SMILESMolGraph</code>: Input molecular graph</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{UInt32}</code>: Hashed invariant values for each atom</li></ul><p><strong>References</strong></p><p>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L42</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L236-L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.SMILESMolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.SMILESMolGraph}"><code>MolecularFingerprints.get_bond_invariants</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_bond_invariants(mol::SMILESMolGraph)</code></pre><p>Compute bond type invariants for all bonds in a molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::SMILESMolGraph</code>: Input molecular graph</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{UInt32}</code>: Bond type codes for each bond in the molecule</li></ul><p><strong>Known Issue</strong></p><p>The edge properties provided by <a href="https://github.com/mojaie/MolecularGraph.jl">MolecularGraph.jl</a> are not in the same order as in RDKit. This results in different hashes and, ultimately, in different fingerprints for larger molecules compared to RDKit. As this would require rework on the smilestomol algorithm provided by <a href="https://github.com/mojaie/MolecularGraph.jl">MolecularGraph.jl</a>, a fix for this issue is currently not in scope of this project.</p><p><strong>References</strong></p><p>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L126</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L293-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}"><a class="docstring-binding" href="#MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}"><code>MolecularFingerprints.mhfp_hash_from_molecular_shingling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mhfp_hash_from_molecular_shingling(shingling::Vector{String}, Encoder::MHFP)</code></pre><p>Calculate the MinHash values from a given Molecular shingling.</p><p>The given encoder contains parameters such as the length of the hashed vector or the  maximum permitted hash number, but also the seed of the rng, and the random numbers that were generated using this seed, that are used in the hashing process.</p><p>The algorithm is described in more detail in the original authors paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L299-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.mhfp_shingling_from_mol"><a class="docstring-binding" href="#MolecularFingerprints.mhfp_shingling_from_mol"><code>MolecularFingerprints.mhfp_shingling_from_mol</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mhfp_shingling_from_mol(
    mol::MolGraph,
    radius::Int = 3,
    rings::Bool = true,
    min_radius::Int = 1)</code></pre><p>Calculate the &quot;molecular shingling&quot; of a given molecule.</p><p>A molecular shingling is a vector of &quot;SMILES&quot;-strings, calculated from the ring  structures and atom types of the molecule (optional), and the circular substructures  around each heavy (=non-hydrogen) atom of the molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: the molecule for which to calculate the shingling.</li><li><code>radius::Int=3</code>: the radius up to which the substructures around each atom should    be considered</li><li><code>rings::Bool=true</code>: if true (default), extract the smallest set of smallest rings   (sssr) of the molecule, and include the SMILES-string of each contained ring in    the molecular shingling</li><li><code>min_radius::Int=1</code>: minimum radius of the substructures around each atom to be    considered. Default is 1. If min_radius=0, include the SMILES-string of each    heavy (i.e., non-hydrogen) atom of the molecule is included in the molecular    shingling.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L117-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}"><a class="docstring-binding" href="#MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}"><code>MolecularFingerprints.rdkit_bond_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rdkit_bond_type(bond::SMILESBond)</code></pre><p>Convert a SMILES bond to RDKit&#39;s bond type encoding.</p><p>Maps bond properties to integer codes matching RDKit&#39;s bond type enumeration.</p><p><strong>Arguments</strong></p><ul><li><code>bond::SMILESBond</code>: Input bond object</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Bond type code (1-6 for single to hextuple, 12 for aromatic, 20 for other, 21 for zero)</li></ul><p><strong>Known Issues</strong></p><p>Due to differences in the internal representation of bonds within MolecularGraph.jl, we currently only support the most common bond types (1 to 6).</p><p><strong>References</strong></p><p>RDKit bond types: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Bond.h#L55</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/ecfp.jl#L254-L273">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_atoms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_from_atoms(mol::MolGraph)</code></pre><p>Return vector containing SMILES strings of all atoms of the given molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L211-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}"><code>MolecularFingerprints.smiles_from_circular_substructures</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_from_circular_substructures(
    mol::MolGraph,
    radius::Int,
    min_radius::Int)</code></pre><p>Return vector of SMILES strings of circular substructures around all atoms of a molecule.</p><p>For each atom of the given molecule, extract the substructures of radii min_radius to radius, and generate their corresponding SMILES strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L247-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_rings</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_from_rings(mol::MolGraph)</code></pre><p>Return vector containing SMILES strings of all rings in the SSSR of the given molecule.</p><p>SSSR stands for the smallest set of smallest rings of the molecule.</p><p>Note: This function uses the function sssr from MolecularGraph.jl, which returns a &quot;true&quot; smallest set of smallest rings of the given molecule. However, in the original implementation of the mhfp algorithm, the &quot;symmetrisized sssr&quot; is used, which in some cases is non-minimal, i.e., contains an additional ring. The rdkit function to get the symmetrisized sssr is not available in MolecularGraph.jl or in RDKitMinimalLib, which is why the standard sssr is used. In most cases, this will not have any effect, but for some molecules, such as cubane, it  will.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/algorithms/mhfp.jl#L181-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.tanimoto-Tuple{BitVector, BitVector}"><a class="docstring-binding" href="#MolecularFingerprints.tanimoto-Tuple{BitVector, BitVector}"><code>MolecularFingerprints.tanimoto</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tanimoto(a::BitVector, b::BitVector) -&gt; Float64</code></pre><p>Calculate the Tanimoto similarity coefficient (Jaccard Index) between two fingerprints. Formula: c / (a + b - c) where c is intersection count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/8a284108676b5a01e11c240622eb808bc90482f8/src/utils/tanimoto.jl#L1-L6">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="getting_started/">Getting Started »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 19 January 2026 16:04">Monday 19 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
