<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MolecularFingerprints.jl</title><meta name="title" content="API Reference · MolecularFingerprints.jl"/><meta property="og:title" content="API Reference · MolecularFingerprints.jl"/><meta property="twitter:title" content="API Reference · MolecularFingerprints.jl"/><meta name="description" content="Documentation for MolecularFingerprints.jl."/><meta property="og:description" content="Documentation for MolecularFingerprints.jl."/><meta property="twitter:description" content="Documentation for MolecularFingerprints.jl."/><meta property="og:url" content="https://LukaszSztukiewicz.github.io/MolecularFingerprints.jl/api_reference/"/><meta property="twitter:url" content="https://LukaszSztukiewicz.github.io/MolecularFingerprints.jl/api_reference/"/><link rel="canonical" href="https://LukaszSztukiewicz.github.io/MolecularFingerprints.jl/api_reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MolecularFingerprints.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../explanation/">Explanation</a></li><li><a class="tocitem" href="../tutorial_getting_started/">Tutorial: Getting Started</a></li><li><a class="tocitem" href="../tutorial_similarity_search/">Tutorial: Similarity Search</a></li><li><a class="tocitem" href="../tutorial_solubility_prediction/">Tutorial: Solubility Prediction</a></li><li><a class="tocitem" href="../fingerprint_types/">Fingerprint Types</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Index-of-Available-Functions-and-Types"><span>Index of Available Functions and Types</span></a></li><li><a class="tocitem" href="#Core-Interface"><span>Core Interface</span></a></li><li><a class="tocitem" href="#Type-Hierarchy"><span>Type Hierarchy</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li><li><a class="tocitem" href="../developer_guide/">Developer Guide</a></li><li><a class="tocitem" href="../validation/">Validation &amp; Testing</a></li><li><a class="tocitem" href="../best_practices/">Best Practices</a></li><li><a class="tocitem" href="../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/main/docs/src/api_reference.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="MolecularFingerprints.jl-API-Reference"><a class="docs-heading-anchor" href="#MolecularFingerprints.jl-API-Reference">MolecularFingerprints.jl API Reference</a><a id="MolecularFingerprints.jl-API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#MolecularFingerprints.jl-API-Reference" title="Permalink"></a></h1><h2 id="Index-of-Available-Functions-and-Types"><a class="docs-heading-anchor" href="#Index-of-Available-Functions-and-Types">Index of Available Functions and Types</a><a id="Index-of-Available-Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Index-of-Available-Functions-and-Types" title="Permalink"></a></h2><ul><li><a href="#MolecularFingerprints.AbstractCalculator"><code>MolecularFingerprints.AbstractCalculator</code></a></li><li><a href="#MolecularFingerprints.AbstractDescriptor"><code>MolecularFingerprints.AbstractDescriptor</code></a></li><li><a href="#MolecularFingerprints.AbstractFingerprint"><code>MolecularFingerprints.AbstractFingerprint</code></a></li><li><a href="#MolecularFingerprints.AccumTuple"><code>MolecularFingerprints.AccumTuple</code></a></li><li><a href="#MolecularFingerprints.ECFP"><code>MolecularFingerprints.ECFP</code></a></li><li><a href="#MolecularFingerprints.MACCS"><code>MolecularFingerprints.MACCS</code></a></li><li><a href="#MolecularFingerprints.MHFP"><code>MolecularFingerprints.MHFP</code></a></li><li><a href="#MolecularFingerprints.MorganAtomEnv"><code>MolecularFingerprints.MorganAtomEnv</code></a></li><li><a href="#MolecularFingerprints.TopologicalTorsion"><code>MolecularFingerprints.TopologicalTorsion</code></a></li><li><a href="#MolecularFingerprints.bond_order_sum-Tuple{Any, Any}"><code>MolecularFingerprints.bond_order_sum</code></a></li><li><a href="#MolecularFingerprints.canonicalize-Tuple{Vector}"><code>MolecularFingerprints.canonicalize</code></a></li><li><a href="#MolecularFingerprints.count_CH3-Tuple{Any}"><code>MolecularFingerprints.count_CH3</code></a></li><li><a href="#MolecularFingerprints.count_atom-Tuple{Any, Symbol}"><code>MolecularFingerprints.count_atom</code></a></li><li><a href="#MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}"><code>MolecularFingerprints.ecfp_atom_invariant</code></a></li><li><a href="#MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}"><code>MolecularFingerprints.ecfp_hash</code></a></li><li><a href="#MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}"><code>MolecularFingerprints.ecfp_hash_combine</code></a></li><li><a href="#MolecularFingerprints.fingerprint"><code>MolecularFingerprints.fingerprint</code></a></li><li><a href="#MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}"><code>MolecularFingerprints.getAtomCode</code></a></li><li><a href="#MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getPathsOfLengthN</code></a></li><li><a href="#MolecularFingerprints.getTTFPCode-Tuple{Vector}"><code>MolecularFingerprints.getTTFPCode</code></a></li><li><a href="#MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getTopologicalTorsionFP</code></a></li><li><a href="#MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.get_atom_invariants</code></a></li><li><a href="#MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.get_bond_invariants</code></a></li><li><a href="#MolecularFingerprints.has_NH-Tuple{Any}"><code>MolecularFingerprints.has_NH</code></a></li><li><a href="#MolecularFingerprints.has_OH-Tuple{Any}"><code>MolecularFingerprints.has_OH</code></a></li><li><a href="#MolecularFingerprints.has_any_bond-Tuple{Any, Symbol, Symbol}"><code>MolecularFingerprints.has_any_bond</code></a></li><li><a href="#MolecularFingerprints.has_atom-Tuple{Any, Symbol}"><code>MolecularFingerprints.has_atom</code></a></li><li><a href="#MolecularFingerprints.has_atom_in_set-Tuple{Any, Set{Symbol}}"><code>MolecularFingerprints.has_atom_in_set</code></a></li><li><a href="#MolecularFingerprints.has_bond-Tuple{Any, Symbol, Symbol, Int64}"><code>MolecularFingerprints.has_bond</code></a></li><li><a href="#MolecularFingerprints.has_path3-Tuple{Any, Symbol, Symbol, Symbol}"><code>MolecularFingerprints.has_path3</code></a></li><li><a href="#MolecularFingerprints.has_ring-Tuple{Any}"><code>MolecularFingerprints.has_ring</code></a></li><li><a href="#MolecularFingerprints.has_ring_of_size-Tuple{Any, Int64}"><code>MolecularFingerprints.has_ring_of_size</code></a></li><li><a href="#MolecularFingerprints.has_strict_path3-Tuple{Any, Symbol, Nothing, Symbol}"><code>MolecularFingerprints.has_strict_path3</code></a></li><li><a href="#MolecularFingerprints.internal_implicit_hydrogens-Tuple{Any, Any}"><code>MolecularFingerprints.internal_implicit_hydrogens</code></a></li><li><a href="#MolecularFingerprints.is_CH2-Tuple{Any, Any}"><code>MolecularFingerprints.is_CH2</code></a></li><li><a href="#MolecularFingerprints.is_CH3-Tuple{Any, Any}"><code>MolecularFingerprints.is_CH3</code></a></li><li><a href="#MolecularFingerprints.max_valence-Tuple{Symbol}"><code>MolecularFingerprints.max_valence</code></a></li><li><a href="#MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}"><code>MolecularFingerprints.mhfp_hash_from_molecular_shingling</code></a></li><li><a href="#MolecularFingerprints.mhfp_shingling_from_mol!-Tuple{MolecularGraph.MolGraph, MHFP}"><code>MolecularFingerprints.mhfp_shingling_from_mol!</code></a></li><li><a href="#MolecularFingerprints.nonH_neighbors-Tuple{Any, Any}"><code>MolecularFingerprints.nonH_neighbors</code></a></li><li><a href="#MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}"><code>MolecularFingerprints.rdkit_bond_type</code></a></li><li><a href="#MolecularFingerprints.safe_atom_symbol-Tuple{Any}"><code>MolecularFingerprints.safe_atom_symbol</code></a></li><li><a href="#MolecularFingerprints.safe_smilestomol-Tuple{String}"><code>MolecularFingerprints.safe_smilestomol</code></a></li><li><a href="#MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_atoms</code></a></li><li><a href="#MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}"><code>MolecularFingerprints.smiles_from_circular_substructures</code></a></li><li><a href="#MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_rings</code></a></li><li><a href="#MolecularFingerprints.smiles_to_neutralized_mol-Tuple{String}"><code>MolecularFingerprints.smiles_to_neutralized_mol</code></a></li><li><a href="#MolecularFingerprints.tanimoto_similarity-Tuple{BitVector, BitVector}"><code>MolecularFingerprints.tanimoto_similarity</code></a></li></ul><h2 id="Core-Interface"><a class="docs-heading-anchor" href="#Core-Interface">Core Interface</a><a id="Core-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MolecularFingerprints.fingerprint"><a class="docstring-binding" href="#MolecularFingerprints.fingerprint"><code>MolecularFingerprints.fingerprint</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fingerprint(smiles::String, calc::AbstractCalculator)</code></pre><p>Calculate the fingerprint for a single SMILES string using the provided <code>calc</code>.</p><p><strong>Arguments</strong></p><ul><li><code>smiles</code>: A string representing the molecule in SMILES format.</li><li><code>calc</code>: A subtype of <code>AbstractCalculator</code> defining the fingerprint type.</li></ul><p><strong>Returns</strong></p><ul><li>A fingerprint representation (the specific type depends on <code>calc</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L74-L85">source</a></section><section><div><pre><code class="language-julia hljs">fingerprint(mol::nothing, calc::AbstractCalculator)</code></pre><p>Handle cases where the molecule is invalid or could not be parsed.</p><p><strong>Arguments</strong></p><ul><li><code>mol</code>: A <code>nothing</code> value indicating an invalid molecule.</li><li><code>calc</code>: A subtype of <code>AbstractCalculator</code> defining the fingerprint type.</li></ul><p><strong>Returns</strong></p><ul><li>A default empty fingerprint based on the calculator type.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L92-L100">source</a></section><section><div><pre><code class="language-julia hljs">fingerprint(smiles_list::Vector{String}, calc::AbstractCalculator)</code></pre><p>Calculate fingerprints for a collection of SMILES strings.</p><p>This method uses multithreading to process the list. Ensure that <code>JULIA_NUM_THREADS</code> is set appropriately before running the code.</p><p><strong>Arguments</strong></p><ul><li><code>smiles_list</code>: A vector of SMILES strings.</li><li><code>calc</code>: The calculator instance to apply to each molecule.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector</code>: A collection of fingerprints, typed according to the first successful calculation.</li></ul><div class="admonition is-info" id="Note-7101248c2478558d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-7101248c2478558d" title="Permalink"></a></header><div class="admonition-body"><p>This function is thread-parallelized using <code>Threads.@threads</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L117-L134">source</a></section><section><div><pre><code class="language-julia hljs">fingerprint(mol::MolGraph, calc::MHFP)</code></pre><p>Calculates the MHFP fingerprint of the given molecule and returns it as a vector of UInt32&#39;s</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L143-L147">source</a></section><section><div><pre><code class="language-julia hljs">fingerprint(mol::MolGraph, calc::ECFP{N}) where N</code></pre><p>Generate an ECFP (Extended-Connectivity Fingerprint) for a molecule.</p><p>This function implements the Morgan/ECFP algorithm as described in the original paper and matching the RDKit implementation. It generates circular fingerprints by iteratively expanding atomic neighborhoods up to the specified radius.</p><p><strong>Algorithm Overview</strong></p><ol><li>Compute initial atom invariants (layer 0)</li><li>For each layer up to the specified radius:<ul><li>Expand atomic neighborhoods by one bond</li><li>Hash neighborhood information to create new invariants</li><li>Detect and eliminate duplicate neighborhoods</li><li>Store unique atomic environments</li></ul></li><li>Map all environment hashes to bit positions in the fingerprint</li></ol><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: Input molecular graph</li><li><code>calc::ECFP{N}</code>: ECFP calculator specifying radius and fingerprint size</li></ul><p><strong>Returns</strong></p><ul><li><code>BitVector</code>: Binary fingerprint of length N with bits set for detected molecular features</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mol = smilestomol(&quot;CCO&quot;)  # Ethanol
fp_calc = ECFP{2048}(2)   # ECFP4 with 2048 bits
fp = fingerprint(mol, fp_calc)</code></pre><p><strong>References</strong></p><ul><li>Rogers, D., &amp; Hahn, M. (2010). Extended-connectivity fingerprints. J. Chem. Inf. Model., 50(5), 742-754.</li><li>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L257</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L313-L348">source</a></section><section><div><pre><code class="language-julia hljs">fingerprint(mol::MolGraph, calc::TopologicalTorsion)</code></pre><p>Returns a topological torsion fingerprint as an integer vector for the molecule belonging to mol.  This function calls function which computes the Topological Torsion fingerprint based on the molecular structure using paths of length pathLength.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: the molecule for which to calculate the fingerprint</li><li><code>calc::TopologicalTorsion</code>: struct containing parameters for fingerprint computation, which is just the path length.   must be at least 2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L37-L48">source</a></section></details></article><h2 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h2><h3 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MolecularFingerprints.AbstractCalculator"><a class="docstring-binding" href="#MolecularFingerprints.AbstractCalculator"><code>MolecularFingerprints.AbstractCalculator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractCalculator</code></pre><p>Supertype for all molecular property calculators. Subtypes should implement  specific calculation logic for molecular properties.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L3-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.AbstractFingerprint"><a class="docstring-binding" href="#MolecularFingerprints.AbstractFingerprint"><code>MolecularFingerprints.AbstractFingerprint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractFingerprint &lt;: AbstractCalculator</code></pre><p>Abstract type for calculators that produce representations  of molecular features (e.g., MACCS, ECFP).</p><p>Unlike descriptors, fingerprints typically represent the presence or absence  of specific substructures or patterns within a molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L11-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.AbstractDescriptor"><a class="docstring-binding" href="#MolecularFingerprints.AbstractDescriptor"><code>MolecularFingerprints.AbstractDescriptor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractDescriptor &lt;: AbstractCalculator</code></pre><p>Abstract type for calculators that produce scalar or numerical molecular properties  (e.g., LogP, Molecular Weight, TPSA).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L22-L27">source</a></section></details></article><h3 id="Concrete-Types"><a class="docs-heading-anchor" href="#Concrete-Types">Concrete Types</a><a id="Concrete-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-Types" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ECFP"><a class="docstring-binding" href="#MolecularFingerprints.ECFP"><code>MolecularFingerprints.ECFP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ECFP{N}(radius::Int = 2)</code></pre><p>Extended-Connectivity Fingerprint (ECFP) calculator.</p><p>ECFPs are circular fingerprints encoding a local molecular environment around each atom up to a specified radius. This implementation closely follows the RDKit algorithm.</p><p><strong>Fields</strong></p><ul><li><code>radius::Int</code>: The maximum number of bonds to traverse from each atom (default: 2)</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>N</code>: The size of the fingerprint bit vector</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create ECFP4 (radius=2) with 2048 bits
fp_calc = ECFP{2048}(2)

# Create ECFP6 (radius=3) with 1024 bits
fp_calc = ECFP{1024}(3)</code></pre><p><strong>References</strong></p><p>Rogers, D., &amp; Hahn, M. (2010). Extended-connectivity fingerprints. Journal of Chemical Information and Modeling, 50(5), 742-754.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L1-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.MHFP"><a class="docstring-binding" href="#MolecularFingerprints.MHFP"><code>MolecularFingerprints.MHFP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MHFP(;
    radius::Int = 3,
    min_radius::Int = 1,
    rings::Bool = true,
    n_permutations::Int = 2048,
    seed::Int = 42
)</code></pre><p>Type for MHFP fingerprint calculators. Contains settings and parameters for  MHFP fingerprint generation.</p><p>The MHFP fingerprint is a vector of UInt32&#39;s, calculated for a given molecule by:</p><ol><li>generating the &quot;molecular shingling&quot; of the molecule, which is a set of strings,   containing:<ol><li>The SMILES strings of all rings in the smallest set of smallest rings (sssr)   of the molecule (optional, corresponds to setting <code>rings=true</code> in the MHFP   calculator object),</li><li>The SMILES strings of the circular substructures of radii <code>min_radius:radius</code> around  each heavy atom of the molecule. Note: if <code>min_radius=0</code>, the corresponding   substructures are just the atoms themselves. </li></ol></li><li>Hashing the molecular shingling, which consists of:<ol><li>Converting each string to a 32-bit integer using SHA1 (and only using the first 32  bits of the hashed result)</li><li>Applying the MinHash scheme to the set of 32-bit integers in order to generate the   final fingerprint. The exact formula is given in the original authors paper, but  we note here that it takes a vector of 32-bit integers as input, and is furthermore  dependent on two vectors a and b, each of a given length k, which is also the length  of the resulting fingerprint vector. The two vectors are sampled at random, but  must be the same for comparable fingerprints. Note: in the fields of MHFP objects,  the vectors a, b and their length k are named <code>_permutations_a</code>, <code>_permutations_b</code>   and <code>n_permutations</code>, respectively.</li></ol></li></ol><p>The avaliable parameters of the calculator object are:</p><p><strong>Given as arguments to the constructor:</strong></p><ul><li><code>radius::Int</code>: The <em>maximum</em> radius of circular substructures around each heavy atom    of a molecule that are to be included in the fingerprint. Typical values are 2 or 3.</li><li><code>min_radius::Int</code>: The <em>minimum</em> radius of circular substructures around each heavy atom   of a molecule that are to be considered. Will be 1 in most cases, however 0 is also    valid; in this case information about the heavy atoms of the molecules is included    explicitly in the fingerprints.</li><li><code>rings::Int</code>: If true, information about rings in the molecules is included in the    fingerprints explicitly.</li></ul><p><strong>Given as keyword arguments to the constructor:</strong></p><ul><li><code>n_permutations::Int</code>: length of the random vectors a and b which are used in    the hashing process. Also corresponds to the length of the final fingerprint.</li><li><code>seed::Int</code>: seed for the generation of the random vectors <code>a</code> and <code>b</code> which are used    in the hashing process. Must be the same for comparable fingerprints.</li></ul><p>Also contains the fields <code>_mersenne_prime</code>, <code>_max_hash</code>, <code>_permutations_a</code> and  <code>_permutations_b</code>, which are internal and cannot be set explicitly. The first two are constants, and the second two are random vectors which are generated  automatically based on the given <code>seed</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L3-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.MACCS"><a class="docstring-binding" href="#MolecularFingerprints.MACCS"><code>MolecularFingerprints.MACCS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MACCS(count::Bool=false, sparse::Bool=false)</code></pre><p>MACCS (Molecular ACCess System) fingerprint calculator.</p><p><strong>Arguments</strong></p><ul><li><code>count</code>: If <code>false</code>, produces a boolean vector (presence/absence). If <code>true</code>, produces a count-based fingerprint.</li><li><code>sparse</code>: If <code>false</code>, produces a dense representation. If <code>true</code>, produces a sparse representation.</li></ul><p><strong>References</strong></p><ul><li><a href="https://doi.org/10.1021/ci010132r">Durant et al., 2002</a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L4-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.TopologicalTorsion"><a class="docstring-binding" href="#MolecularFingerprints.TopologicalTorsion"><code>MolecularFingerprints.TopologicalTorsion</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TopologicalTorsion(pathLength::Int=4)</code></pre><p>Topological Torsion fingerprint calculator.</p><p><strong>Arguments</strong></p><ul><li><code>pathLength</code>: Length of the paths in the molecular graph to consider (default is</li></ul><p>4).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L22-L28">source</a></section></details></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MolecularFingerprints.AccumTuple"><a class="docstring-binding" href="#MolecularFingerprints.AccumTuple"><code>MolecularFingerprints.AccumTuple</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AccumTuple(;
    bits::BitVector,
    invariant::UInt32,
    atom_index::Int
)</code></pre><p>Internal structure for tracking and comparing atomic neighborhoods during ECFP generation.</p><p>Used to detect duplicate neighborhoods and maintain consistency with RDKit&#39;s algorithm by storing bond connectivity patterns along with invariant hashes.</p><p><strong>Fields</strong></p><ul><li><code>bits::BitVector</code>: Bit representation of the bond neighborhood</li><li><code>invariant::UInt32</code>: Hash invariant for this neighborhood</li><li><code>atom_index::Int</code>: Index of the central atom</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L195-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.MorganAtomEnv"><a class="docstring-binding" href="#MolecularFingerprints.MorganAtomEnv"><code>MolecularFingerprints.MorganAtomEnv</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MorganAtomEnv(;
    code::UInt32,
    atom_id::Int,
    layer::Int
)</code></pre><p>Internal structure representing a Morgan atom environment.</p><p>Stores the hash code, atom identifier (index), and layer/radius for each atomic environment encountered during ECFP fingerprint generation.</p><p><strong>Fields</strong></p><ul><li><code>code::UInt32</code>: Hash code representing the atomic environment</li><li><code>atom_id::Int</code>: Identifier of the central atom</li><li><code>layer::Int</code>: Radius/layer at which this environment was computed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L170-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.bond_order_sum-Tuple{Any, Any}"><a class="docstring-binding" href="#MolecularFingerprints.bond_order_sum-Tuple{Any, Any}"><code>MolecularFingerprints.bond_order_sum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bond_order_sum(mol, v) -&gt; Int</code></pre><p>Count sum of bond orders for atom v in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L276-L280">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.canonicalize-Tuple{Vector}"><a class="docstring-binding" href="#MolecularFingerprints.canonicalize-Tuple{Vector}"><code>MolecularFingerprints.canonicalize</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">canonicalize(path::Vector{Int})</code></pre><p><strong>Arguments</strong></p><ul><li><code>path::Vector</code>: Vertex indices of a cycle from the molecular graph</li></ul><p>Canonicalization is done to obtain unique fingerprints for different smiles strings as described in https://depth-first.com/articles/2021/10/06/molecular-graph-canonicalization/.   Since every ring is found pathLength times, we have to abandon all but one ring.   We only keep the ring which starts at the lowest numbered vertex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L153-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.count_CH3-Tuple{Any}"><a class="docstring-binding" href="#MolecularFingerprints.count_CH3-Tuple{Any}"><code>MolecularFingerprints.count_CH3</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">count_CH3(mol) -&gt; Int</code></pre><p>Count how many CH3 groups are in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L229-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.count_atom-Tuple{Any, Symbol}"><a class="docstring-binding" href="#MolecularFingerprints.count_atom-Tuple{Any, Symbol}"><code>MolecularFingerprints.count_atom</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">count_atom(mol, sym::Symbol) -&gt; Int</code></pre><p>Count how many atoms (sym::Symbol) are in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L55-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}"><a class="docstring-binding" href="#MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}"><code>MolecularFingerprints.ecfp_atom_invariant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ecfp_atom_invariant(smiles::AbstractString)
ecfp_atom_invariant(mol::AbstractMolGraph)
ecfp_atom_invariant(mol::AbstractMolGraph, atom_index)</code></pre><p>Calculate atomic invariants for ECFP fingerprint generation.</p><p>The atomic invariants are properties of an atom that don&#39;t depend on initial atom numbering, based on the Daylight atomic invariants. This implementation follows the RDKit approach.</p><p><strong>Arguments</strong></p><ul><li><code>smiles::AbstractString</code>: SMILES string representation of a molecule</li><li><code>mol::AbstractMolGraph</code>: Molecular graph structure</li><li><code>atom_index</code>: Index of the specific atom to compute invariants for. If not specified, invariants for all atoms are computed and returned</li></ul><p><strong>Returns</strong></p><ul><li>For single atom: <code>Vector{UInt32}</code> containing the invariant components</li><li>For all atoms: <code>Vector{Vector{UInt32}}</code> with invariants for each atom</li></ul><p><strong>Invariant Components</strong></p><p>The computed invariants include (in order):</p><ol><li>Atomic number</li><li>Total degree (number of neighbors including implicit hydrogens)</li><li>Total number of hydrogens (implicit + explicit)</li><li>Atomic charge</li><li>Delta mass (difference from standard isotope mass)</li><li>Ring membership indicator (1 if atom is in a ring, omitted otherwise)</li></ol><p><strong>References</strong></p><p>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/FingerprintUtil.cpp#L244</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L42-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}"><a class="docstring-binding" href="#MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}"><code>MolecularFingerprints.ecfp_hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ecfp_hash(v::Vector{UInt32})</code></pre><p>Generate a hash value from a vector of UInt32 values.</p><p>Iteratively combines all values in the vector using the ECFP hash combining algorithm to produce a single hash value representing the entire vector.</p><p><strong>Arguments</strong></p><ul><li><code>v::Vector{UInt32}</code>: Vector of values to hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt32</code>: Hash value representing the input vector</li></ul><p><strong>References</strong></p><p>Boost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/RDGeneral/hash/hash.hpp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L145-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}"><a class="docstring-binding" href="#MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}"><code>MolecularFingerprints.ecfp_hash_combine</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ecfp_hash_combine(seed::UInt32, value::UInt32)</code></pre><p>Combine two hash values using the boost hash_combine algorithm.</p><p>This function implements the hash combining strategy used in RDKit&#39;s ECFP implementation, which is based on the boost C++ library&#39;s hash_combine function.</p><p><strong>Arguments</strong></p><ul><li><code>seed::UInt32</code>: Current hash seed value</li><li><code>value::UInt32</code>: New value to combine into the hash</li></ul><p><strong>Returns</strong></p><ul><li><code>UInt32</code>: Combined hash value</li></ul><p><strong>References</strong></p><p>Boost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/RDGeneral/hash/hash.hpp</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L123-L140">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}"><code>MolecularFingerprints.getAtomCode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getAtomCode(degree::Int, piBond::Int, atomicNumber::Int)</code></pre><p>Calculates an integer for an atom of a molecule from number of non-hydrogen branches, number of pi bonds and atomic number</p><p><strong>Arguments</strong></p><ul><li><code>degree::Int</code>: number of non-hydrogen branches</li><li><code>piBond::Int</code>: number of pi bonds</li><li><code>atomicNumber::Int</code>: atomic number</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L211-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getPathsOfLengthN</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getPathsOfLengthN(mol::MolGraph, N::Int)</code></pre><p>Returns a list of all simple paths of length N and cycles of length N - 1 in the Molecular Graph.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: the molecule from which to extract the walks</li><li><code>N::Int</code>: length of the walks, meaning number of vertices in walk</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L112-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getTTFPCode-Tuple{Vector}"><a class="docstring-binding" href="#MolecularFingerprints.getTTFPCode-Tuple{Vector}"><code>MolecularFingerprints.getTTFPCode</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getTTFPCode(pathCodes::Vector)</code></pre><p>Calculates an integer from a number calculated from the atom codes of a path which will serve  as an index for which the fingerprint will be increased by 1.</p><p><strong>Arguments</strong></p><ul><li><code>pathCodes::Vector</code>: contains a code generated from the atom codes of molecules of a path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L174-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}"><code>MolecularFingerprints.getTopologicalTorsionFP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getTopologicalTorsionFP(mol::MolGraph, pathLength::Int)</code></pre><p>Returns the Topological Torsion Fingerprint of a molecule as a sparse Int Vector. This function loops over all simple paths of length pathLength and all cycles of length pathLength - 1 of the molecular graph,  and gets a number for each atom in a path, an &quot;Atom Code&quot; from which a sparse IntVector is calculated.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: the molecule for which to calculate the fingerprint</li><li><code>pathLength::Int</code>: length of walks from molecular graph used to calculated fingerprint</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/torsions.jl#L56-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.MolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.get_atom_invariants</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_atom_invariants(mol::MolGraph)</code></pre><p>Compute hashed atom invariants for all atoms in a molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: Input molecular graph</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{UInt32}</code>: Hashed invariant values for each atom</li></ul><p><strong>References</strong></p><p>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L42</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L232-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.MolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.get_bond_invariants</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_bond_invariants(mol::MolGraph)</code></pre><p>Compute bond type invariants for all bonds in a molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: Input molecular graph</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{UInt32}</code>: Bond type codes for each bond in the molecule</li></ul><p><strong>Known Issue</strong></p><p>The edge properties provided by <a href="https://github.com/mojaie/MolecularGraph.jl">MolecularGraph.jl</a> are not in the same order as in RDKit. This results in different hashes and, ultimately, in different fingerprints for larger molecules compared to RDKit. As this would require rework on the smilestomol algorithm provided by <a href="https://github.com/mojaie/MolecularGraph.jl">MolecularGraph.jl</a>, a fix for this issue is currently not in scope of this project.</p><p><strong>References</strong></p><p>RDKit implementation: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L126</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L289-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_NH-Tuple{Any}"><a class="docstring-binding" href="#MolecularFingerprints.has_NH-Tuple{Any}"><code>MolecularFingerprints.has_NH</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_NH(mol) -&gt; Bool</code></pre><p>Check whether molecule (mol) has NH group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L213-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_OH-Tuple{Any}"><a class="docstring-binding" href="#MolecularFingerprints.has_OH-Tuple{Any}"><code>MolecularFingerprints.has_OH</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_OH(mol) -&gt; Bool</code></pre><p>Check whether molecule (mol) has OH group</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L197-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_any_bond-Tuple{Any, Symbol, Symbol}"><a class="docstring-binding" href="#MolecularFingerprints.has_any_bond-Tuple{Any, Symbol, Symbol}"><code>MolecularFingerprints.has_any_bond</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_any_bond(mol, s1::Symbol, s2::Symbol)-&gt; Bool</code></pre><p>N~S - check whether there is at least one bond between atoms (s1::Symbol, s2::Symbol) in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L97-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_atom-Tuple{Any, Symbol}"><a class="docstring-binding" href="#MolecularFingerprints.has_atom-Tuple{Any, Symbol}"><code>MolecularFingerprints.has_atom</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_atom(mol, sym::Symbol) -&gt; Bool</code></pre><p>Check whether atom (sym::Symbol) is contained in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L39-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_atom_in_set-Tuple{Any, Set{Symbol}}"><a class="docstring-binding" href="#MolecularFingerprints.has_atom_in_set-Tuple{Any, Set{Symbol}}"><code>MolecularFingerprints.has_atom_in_set</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_atom_in_set(mol, syms::Set{Symbol}) -&gt; Bool</code></pre><p>Check whether at least one atom of molecule (mol) is in set of atoms (syms::Set{Symbol})    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L160-L164">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_bond-Tuple{Any, Symbol, Symbol, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.has_bond-Tuple{Any, Symbol, Symbol, Int64}"><code>MolecularFingerprints.has_bond</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>has_bond(mol, s1::Symbol, s2::Symbol, order::Int) -&gt; Bool</p><p>Check whether a bond exists between atoms (s1::Symbol, s2::Symbol) with given order in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L72-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_path3-Tuple{Any, Symbol, Symbol, Symbol}"><a class="docstring-binding" href="#MolecularFingerprints.has_path3-Tuple{Any, Symbol, Symbol, Symbol}"><code>MolecularFingerprints.has_path3</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_path3(mol, s1::Union{Symbol}, s2::Union{Symbol}, s3::Union{Symbol}) -&gt; Bool</code></pre><p>A~B~C - check whether there is a path of length 3 between atoms (s1::Symbol, s2::Symbol, s3::Symbol) in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L115-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_ring-Tuple{Any}"><a class="docstring-binding" href="#MolecularFingerprints.has_ring-Tuple{Any}"><code>MolecularFingerprints.has_ring</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_ring(mol) -&gt; Bool</code></pre><p>Check whether molecule (mol) has at least one ring</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L170-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_ring_of_size-Tuple{Any, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.has_ring_of_size-Tuple{Any, Int64}"><code>MolecularFingerprints.has_ring_of_size</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_ring_of_size(mol, n::Int) -&gt; Bool</code></pre><p>Check whether molecule (mol) has a ring of given size (n::Int)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L182-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.has_strict_path3-Tuple{Any, Symbol, Nothing, Symbol}"><a class="docstring-binding" href="#MolecularFingerprints.has_strict_path3-Tuple{Any, Symbol, Nothing, Symbol}"><code>MolecularFingerprints.has_strict_path3</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_strict_path3(mol, s1::Symbol, s2::Nothing, s3::Symbol) -&gt; Bool</code></pre><p>A~X~C - check whether there is a path of length 3 between atoms (s1::Symbol, s3::Symbol) in molecule (mol), where X can be any atom</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L138-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.internal_implicit_hydrogens-Tuple{Any, Any}"><a class="docstring-binding" href="#MolecularFingerprints.internal_implicit_hydrogens-Tuple{Any, Any}"><code>MolecularFingerprints.internal_implicit_hydrogens</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">internal_implicit_hydrogens(mol, v) -&gt; Int</code></pre><p>Count how many implicit (invisible) hydrogens atom v has in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L243-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.is_CH2-Tuple{Any, Any}"><a class="docstring-binding" href="#MolecularFingerprints.is_CH2-Tuple{Any, Any}"><code>MolecularFingerprints.is_CH2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_CH2(mol, v) -&gt; Bool</code></pre><p>Check wheter atom v is in group CH2 in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L305-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.is_CH3-Tuple{Any, Any}"><a class="docstring-binding" href="#MolecularFingerprints.is_CH3-Tuple{Any, Any}"><code>MolecularFingerprints.is_CH3</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_CH3(mol, v) -&gt; Bool</code></pre><p>Check wheter atom v is in group CH3 in molecule (mol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L294-L298">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.max_valence-Tuple{Symbol}"><a class="docstring-binding" href="#MolecularFingerprints.max_valence-Tuple{Symbol}"><code>MolecularFingerprints.max_valence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_valence(sym::Symbol) -&gt; Int</code></pre><p>Returns valence for given atom symbol (sym::Symbol)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L262-L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}"><a class="docstring-binding" href="#MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}"><code>MolecularFingerprints.mhfp_hash_from_molecular_shingling</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mhfp_hash_from_molecular_shingling(shingling::Vector{String}, calc::MHFP)</code></pre><p>Calculate the MinHash values from a given Molecular shingling.</p><p>The given calculator contains parameters such as the length of the random vectors a , b that are used in the hashing scheme, as well as the seed used when generating them. The algorithm is described in more detail in the original authors paper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L343-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.mhfp_shingling_from_mol!-Tuple{MolecularGraph.MolGraph, MHFP}"><a class="docstring-binding" href="#MolecularFingerprints.mhfp_shingling_from_mol!-Tuple{MolecularGraph.MolGraph, MHFP}"><code>MolecularFingerprints.mhfp_shingling_from_mol!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mhfp_shingling_from_mol!(
    mol::MolGraph,
    calc::MHFP)</code></pre><p>Calculate the &quot;molecular shingling&quot; of a given molecule.</p><p>A molecular shingling is a vector of &quot;SMILES&quot;-strings, calculated from the ring  structures and atom types of the molecule (optional), and the circular substructures  around each heavy (=non-hydrogen) atom of the molecule.</p><p><strong>Arguments</strong></p><ul><li><code>mol::MolGraph</code>: the molecule for which to calculate the shingling.</li><li><code>calc::MHFP</code>: fingeprint &quot;calculator&quot; object, containing the relevant parameters for the    fingerprint calculation, e.g., the radii of the circular substructures to be considered   and whether to include ring information explicitly in the fingerprints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L154-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.nonH_neighbors-Tuple{Any, Any}"><a class="docstring-binding" href="#MolecularFingerprints.nonH_neighbors-Tuple{Any, Any}"><code>MolecularFingerprints.nonH_neighbors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nonH_neighbors(mol, v) -&gt; Vector{Int}</code></pre><p>Get neighbors of atom v in molecule (mol) which are NOT hydrogen</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L316-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}"><a class="docstring-binding" href="#MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}"><code>MolecularFingerprints.rdkit_bond_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rdkit_bond_type(bond::SMILESBond)</code></pre><p>Convert a SMILES bond to RDKit&#39;s bond type encoding.</p><p>Maps bond properties to integer codes matching RDKit&#39;s bond type enumeration.</p><p><strong>Arguments</strong></p><ul><li><code>bond::SMILESBond</code>: Input bond object</li></ul><p><strong>Returns</strong></p><ul><li><code>Int</code>: Bond type code (1-6 for single to hextuple, 12 for aromatic, 20 for other, 21 for zero)</li></ul><p><strong>Known Issues</strong></p><p>Due to differences in the internal representation of bonds within MolecularGraph.jl, we currently only support the most common bond types (1 to 6).</p><p><strong>References</strong></p><p>RDKit bond types: https://github.com/rdkit/rdkit/blob/Release<em>2025</em>09_4/Code/GraphMol/Bond.h#L55</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/ecfp.jl#L250-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.safe_atom_symbol-Tuple{Any}"><a class="docstring-binding" href="#MolecularFingerprints.safe_atom_symbol-Tuple{Any}"><code>MolecularFingerprints.safe_atom_symbol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">safe_atom_symbol(atom)</code></pre><p>Returns the atom symbol as a Symbol type (:C) not string (&quot;C&quot;)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/maccs.jl#L27-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.safe_smilestomol-Tuple{String}"><a class="docstring-binding" href="#MolecularFingerprints.safe_smilestomol-Tuple{String}"><code>MolecularFingerprints.safe_smilestomol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">safe_smilestomol(smiles::String)</code></pre><p>Attempts to parse a SMILES string. Returns nothing if it fails instead of crashing the entire thread.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L31-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_atoms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_from_atoms(mol::MolGraph)</code></pre><p>Return vector containing SMILES strings of all atoms of the given molecule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L242-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}"><code>MolecularFingerprints.smiles_from_circular_substructures</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_from_circular_substructures(
    mol::MolGraph,
    radius::Int,
    min_radius::Int)</code></pre><p>Return vector of SMILES strings of circular substructures around all atoms of a molecule.</p><p>For each atom of the given molecule, extract the substructures of radii min_radius to radius, and generate their corresponding SMILES strings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L278-L288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}"><code>MolecularFingerprints.smiles_from_rings</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_from_rings(mol::MolGraph)</code></pre><p>Return vector containing SMILES strings of all rings in the SSSR of the given molecule.</p><p>SSSR stands for the smallest set of smallest rings of the molecule.</p><p>Note: This function uses the function sssr from MolecularGraph.jl, which returns a &quot;true&quot; smallest set of smallest rings of the given molecule. However, in the original implementation of the mhfp algorithm, the &quot;symmetrisized sssr&quot; is used, which in some cases is non-minimal, i.e., contains an additional ring. The rdkit function to get the symmetrisized sssr is not available in MolecularGraph.jl or in RDKitMinimalLib, which is why the standard sssr is used. In most cases, this will not have any effect, but for some molecules, such as cubane, it  will.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/algorithms/mhfp.jl#L212-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.smiles_to_neutralized_mol-Tuple{String}"><a class="docstring-binding" href="#MolecularFingerprints.smiles_to_neutralized_mol-Tuple{String}"><code>MolecularFingerprints.smiles_to_neutralized_mol</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smiles_to_neutralized_mol(smiles_string::String)</code></pre><p>Convert a SMILES string to a neutralized <code>MolGraph</code> instance. This function identifies the largest fragment in the SMILES string, removes charges from common organic elements, and returns the corresponding <code>MolGraph</code>.</p><p><strong>Arguments</strong></p><ul><li><code>smiles_string</code>: A string representing the molecule in SMILES format.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>MolGraph</code> instance of the neutralized largest fragment.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/interface.jl#L46-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MolecularFingerprints.tanimoto_similarity-Tuple{BitVector, BitVector}"><a class="docstring-binding" href="#MolecularFingerprints.tanimoto_similarity-Tuple{BitVector, BitVector}"><code>MolecularFingerprints.tanimoto_similarity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tanimoto_similarity(a::BitVector, b::BitVector)</code></pre><p>Calculate the tanimoto_similarity similarity coefficient (Jaccard Index) between two fingerprints. Formula: c / (a + b - c) where c is intersection count.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl/blob/2d065f663043c851e19d96a31bb97e679bfb1ecd/src/utils/tanimoto_similarity.jl#L1-L6">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../fingerprint_types/">« Fingerprint Types</a><a class="docs-footer-nextpage" href="../developer_guide/">Developer Guide »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 27 January 2026 17:23">Tuesday 27 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
