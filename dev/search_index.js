var documenterSearchIndex = {"docs":
[{"location":"explanation/#Why-MolecularFingerprints.jl?","page":"Explanation","title":"Why MolecularFingerprints.jl?","text":"If you are coming from a computer science background, you are likely used to thinking about data in terms of arrays, hashes, or objects. In chemoinformatics, our primary challenge is representing a real chemical molecule in a format that a computer can actually work with efficiently.","category":"section"},{"location":"explanation/#Why-we-need-fingerprints","page":"Explanation","title":"Why we need fingerprints","text":"Most chemical data is stored as Simplified Molecular Input Line Entry System (SMILES) strings, like CCO for ethanol or C1=CC=CC=C1 for benzene. While these are great for humans to read and for databases to store, they are pretty difficult to use for actual computation. \n\nYou cannot perform vector math on a string, and standard string distance metrics like Levenshtein distance do not correspond to chemical similarity. A small change in a SMILES string can represent a huge change in the actual molecule, and vice versa. For example, the SMILES strings CCO (ethanol) and CC=O (acetaldehyde) differ by just one character, but the molecules have very different properties. On the other hand, CCO (ethanol) and C(C)O (also ethanol) look quite different as strings but represent the same molecule.\n\nThis is why we use molecular fingerprints. We essentially take the molecular graph and transform it into a high-dimensional vector.","category":"section"},{"location":"explanation/#How-they-work","page":"Explanation","title":"How they work","text":"A molecular fingerprint is typically a fixed-length vector where each vector entry represents the presence or absence of a specific structural feature. We generate these through a few different strategies:\n\nPath-based methods traverse the molecular graph and identify all possible paths of a certain length, hashing those paths into the fingerprint vector.\nCircular methods look at the local neighborhood around each individual atom, iteratively expanding outward to capture the local environment.\nSubstructure methods check the molecule against a predefined library of chemical substructures (motifs), like searching for a specific regex in a block of text.","category":"section"},{"location":"explanation/#Practical-applications","page":"Explanation","title":"Practical applications","text":"","category":"section"},{"location":"explanation/#Similarity-searching","page":"Explanation","title":"Similarity searching","text":"Once you have converted a molecule into a fingerprint vector, you can use concepts you are already familiar with in Computer Science. For example, we use the Tanimoto similarity (which is just another name for the Jaccard similarity) to calculate how similar two molecules are. This allows us to perform lightning-fast similarity searches across databases containing millions of compounds.","category":"section"},{"location":"explanation/#Machine-learning","page":"Explanation","title":"Machine learning","text":"These vectors also serve as the standard input for machine learning models. If you want to predict whether a molecule is toxic or if it will bind to a specific protein, these fingerprints provide the fixed-length feature set you need for a random forest, a support vector machine, or a neural network.","category":"section"},{"location":"explanation/#Why-MolecularFingerprints.jl-in-Julia?","page":"Explanation","title":"Why MolecularFingerprints.jl in Julia?","text":"There exist several cheminformatics libraries in other programming languages, such as RDKit in Python or CDK in Java. However, we wanted to create a native Julia implementation to leverage Julia's strengths in scientific computing, performance, and ease of use. Julia's multiple dispatch system allows us to create flexible and extensible fingerprinting algorithms that can be easily integrated into larger cheminformatics workflows. \n\nMolecularFingerprints.jl is designed to have minimal dependencies, making it lightweight and easy to install. This allows users to quickly get started with molecular fingerprinting without the overhead of large external libraries.\n\nIt is also designed to interoperate seamlessly with other Julia packages in the cheminformatics ecosystem, such as MolecularGraph.jl for molecular representation and manipulation. ","category":"section"},{"location":"fingerprint_types/#MolecularFingerprints.jl-Fingerprint-Types","page":"Fingerprint Types","title":"MolecularFingerprints.jl - Fingerprint Types","text":"This section breaks down the specific algorithms we have implemented in this package. As a computer scientist, it helps to think of these as different ways to hash a graph. Depending on which structural features you want to emphasize—local neighborhoods, specific functional groups, or long-range connectivity—you might choose one over the other.","category":"section"},{"location":"fingerprint_types/#Extended-Connectivity-Fingerprints-(ECFP)","page":"Fingerprint Types","title":"Extended Connectivity Fingerprints (ECFP)","text":"ECFPs are the industry standard for most tasks today. In the CS world, you can think of these as a variation of the Weisfeiler-Lehman graph isomorphism test. The algorithm works by looking at each atom and its immediate neighbors, assigning them an initial integer identifier. It then iteratively updates these identifiers by looking at neighbors at increasing distances—usually referred to as the radius. Once the iterations are complete, all the unique identifiers are hashed into a bit vector of a fixed size, like 1024 or 2048. Because they capture local circular environments, they are incredibly effective at identifying similar molecular \"building blocks\" regardless of where they appear in the molecule.","category":"section"},{"location":"fingerprint_types/#MACCS-Keys","page":"Fingerprint Types","title":"MACCS Keys","text":"If ECFPs are like a dynamic hashing algorithm, MACCS keys are more like a checklist. This is a dictionary-based approach where each bit in the vector corresponds to a specific, predefined chemical question. For instance, bit 160 might ask: \"Is there at least one oxygen atom present?\" and bit 161 might ask: \"Is there a nitrogen-hydrogen bond?\". There are 166 of these keys in total. While this is a older and much more rigid approach than modern hashing methods, it remains very popular because the results are highly interpretable. You know exactly what each bit represents, which is not usually the case with hashed fingerprints.","category":"section"},{"location":"fingerprint_types/#MHFP-(Molecular-Hash-Fingerprints)","page":"Fingerprint Types","title":"MHFP (Molecular Hash Fingerprints)","text":"MHFP is a more recent development designed specifically for very large-scale datasets. It borrows heavily from the MinHash technique used in natural language processing and document deduplication. Instead of just hashing structural fragments into a bit vector, MHFP uses a MinHash-based scheme to create a signature that is very efficient for locality-sensitive hashing (LSH). This makes it possible to perform similarity searches across billions of molecules in sub-second time. If you are building a search engine for chemical space, this is likely the algorithm you would reach for.","category":"section"},{"location":"fingerprint_types/#Topological-Torsion-Fingerprints","page":"Fingerprint Types","title":"Topological Torsion Fingerprints","text":"Topological torsion fingerprints take a linear approach rather than a circular one. Instead of looking at neighborhoods, they identify all sequences of four bonded atoms—which we call torsions—and record the types of atoms, their bond orders, and the number of non-hydrogen neighbors. These paths are then hashed into the fingerprint. This method is particularly sensitive to the overall shape and \"skeleton\" of the molecule. It is often used as a complementary tool to ECFP because it captures the long-range connectivity of the molecular graph that circular methods might overlook.","category":"section"},{"location":"best_practices/#Best-Practices-for-Using-MolecularFingerprints.jl","page":"Best Practices","title":"Best Practices for Using MolecularFingerprints.jl","text":"To get the most out of MolecularFingerprints.jl, keep the following engineering principles in mind:","category":"section"},{"location":"best_practices/#1.-Leverage-Type-Specialization","page":"Best Practices","title":"1. Leverage Type Specialization","text":"Julia's compiler specializes code based on types. By defining your calculator once (e.g., calc = ECFP{2048}(3)), you allow the compiler to optimize the internal loops for that specific bit-length. Avoid redefining the calculator inside loops.","category":"section"},{"location":"best_practices/#2.-Threading-Performance","page":"Best Practices","title":"2. Threading Performance","text":"The batch fingerprint function uses Threads.@threads. To ensure you are actually using multiple cores, check your environment:\n\nusing Base.Threads\nprintln(nthreads()) # Should be > 1\n\n\nIf it returns 1, start Julia with julia -t auto.","category":"section"},{"location":"best_practices/#3.-Bit-Vector-vs.-Dense-Vector","page":"Best Practices","title":"3. Bit-Vector vs. Dense Vector","text":"Note that fingerprints are returned as BitVector objects. This is memory-efficient (1 bit per element) and allows for high-speed logical operations (AND, OR, XOR) which are critical for calculating Tanimoto similarities.","category":"section"},{"location":"best_practices/#4.-Canonicalization","page":"Best Practices","title":"4. Canonicalization","text":"While the library handles SMILES parsing, remember that different SMILES strings can represent the same molecular graph (e.g., C1=CC=CC=C1 vs c1ccccc1). For consistency in machine learning tasks, ensure your input data is canonicalized.","category":"section"},{"location":"tutorial_similarity_search/#Similarity-Search:-Finding-Chemically-Related-Molecules","page":"Tutorial: Similarity Search","title":"Similarity Search: Finding Chemically Related Molecules","text":"In this tutorial, we will find the most chemically similar molecules in a database relative to a \"query\" molecule.\n\n","category":"section"},{"location":"tutorial_similarity_search/#1.-Setup-and-Library-Loading","page":"Tutorial: Similarity Search","title":"1. Setup and Library Loading","text":"We will use the same core libraries: MolecularFingerprints.jl for generating descriptors and MolecularGraph.jl for parsing molecules.\n\nusing LinearAlgebra\nusing MolecularFingerprints\nusing MolecularGraph\n\n# A small \"database\" of molecules\ndatabase_smiles = [\n    \"CCO\",                # Ethanol\n    \"CC(=O)Oc1ccccc1C(=O)O\", # Aspirin\n    \"c1ccccc1\",           # Benzene\n    \"CCCCCCCC\",           # Octane\n    \"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\", # Caffeine\n    \"CC(C)CC1=CC=C(C=C1)C(C)C(=O)O\"  # Ibuprofen\n]\n\n# Our Query Molecule: Acetaminophen (Paracetamol)\nquery_smiles = \"CC(=O)Nc1ccc(O)cc1\"\n\n\n","category":"section"},{"location":"tutorial_similarity_search/#2.-Fingerprinting-the-Database","page":"Tutorial: Similarity Search","title":"2. Fingerprinting the Database","text":"To compare molecules, we must first map them into the same vector space. We'll use Morgan Fingerprints (ECFP4), which capture the local neighborhood of atoms.\n\n# Convert database to molecules and then to fingerprints\ndb_mols = [smilestomol(s) for s in database_smiles]\nfeaturizer = ECFP{2}(2) # Radius 2 (ECFP4 equivalent)\n\n# Generate a list of BitVectors\ndb_fps = [fingerprint(m, featurizer) for m in db_mols]\n\n# Process the Query Molecule\nquery_mol = smilestomol(query_smiles)\nquery_fp = fingerprint(query_mol, featurizer)\n\n\n","category":"section"},{"location":"tutorial_similarity_search/#3.-Calculating-Tanimoto-Similarity","page":"Tutorial: Similarity Search","title":"3. Calculating Tanimoto Similarity","text":"In cheminformatics, the tanimoto_similarity Coefficient (or Jaccard Index) is the industry standard for comparing bit-vector fingerprints. It measures the intersection of features divided by the union.\n\nA score of 1.0 means the fingerprints are identical; 0.0 means they share no common features.\n\n# Function to calculate tanimoto_similarity between two BitVectors\nfunction tanimoto_similarity_similarity(fp1, fp2)\n    intersection = sum(fp1 .& fp2)\n    union = sum(fp1 .| fp2)\n    return intersection / union\nend\n\n# Calculate similarity between query and every item in the database\nsimilarities = [tanimoto_similarity(query_fp, db_fp) for db_fp in db_fps]\n\n# Pair the SMILES with their scores for easy reading\nresults = collect(zip(database_smiles, similarities))\n\n\n","category":"section"},{"location":"tutorial_similarity_search/#4.-Ranking-and-Results","page":"Tutorial: Similarity Search","title":"4. Ranking and Results","text":"Finally, we sort our database based on the similarity score to find the closest matches.\n\n# Sort by similarity score in descending order\nsort!(results, by = x -> x[2], rev = true)\n\nprintln(\"Similarity Search Results for Query: $query_smiles\")\nprintln(\"-\"^45)\nfor (smiles, score) in results\n    println(\"Score: $(round(score, digits=3)) | Molecule: $smiles\")\nend\n","category":"section"},{"location":"faq/#Frequently-Asked-Questions-(FAQ)","page":"FAQ","title":"Frequently Asked Questions (FAQ)","text":"","category":"section"},{"location":"faq/#What-is-a-molecular-fingerprint?","page":"FAQ","title":"What is a molecular fingerprint?","text":"A molecular fingerprint is a fixed-length vector representation of a molecule, where each bit indicates the presence or absence of specific structural features or patterns within the molecule. This representation allows for efficient computation, similarity searching, and machine learning applications in cheminformatics. More extensive explanations can be found in the Explanation section of the documentation.","category":"section"},{"location":"faq/#How-do-I-choose-the-right-fingerprint-type-for-my-application?","page":"FAQ","title":"How do I choose the right fingerprint type for my application?","text":"The choice of fingerprint type depends on your specific application and the characteristics of the molecules you are working with. Common types include ECFP (Extended Connectivity Fingerprints) for capturing local atomic environments, MACCS keys for substructure presence, and path-based fingerprints for capturing linear paths in the molecular graph. Consider the size of your dataset, the nature of your molecules, and the computational resources available when selecting a fingerprint type.","category":"section"},{"location":"faq/#Can-I-customize-the-size-and-parameters-of-the-fingerprints?","page":"FAQ","title":"Can I customize the size and parameters of the fingerprints?","text":"Yes, most fingerprint types in MolecularFingerprints.jl allow you to customize parameters such as the size of the fingerprint vector and specific algorithm settings (e.g., radius for ECFP). Refer to the documentation for details on how to configure these parameters. See the API Reference for more information.","category":"section"},{"location":"faq/#Will-this-package-provide-descriptors-in-addition-to-fingerprints?","page":"FAQ","title":"Will this package provide descriptors in addition to fingerprints?","text":"MolecularFingerprints.jl is primarily focused on generating molecular fingerprints. However, it is designed to be compatible with other Julia packages that provide molecular descriptors, allowing you to use both fingerprints and descriptors in your analyses.","category":"section"},{"location":"tutorial_getting_started/#Getting-Started-with-MolecularFingerprints.jl","page":"Tutorial: Getting Started","title":"Getting Started with MolecularFingerprints.jl","text":"This guide will help you set up your environment and compute your first molecular representations.","category":"section"},{"location":"tutorial_getting_started/#Installation","page":"Tutorial: Getting Started","title":"Installation","text":"We recommend using Julia's built-in package manager (Pkg) to manage dependencies. Choose the method that best fits your workflow:","category":"section"},{"location":"tutorial_getting_started/#Option-1:-Sandbox-(Trial)","page":"Tutorial: Getting Started","title":"Option 1: Sandbox (Trial)","text":"Best for a quick \"Hello World\" or testing a specific feature without modifying your global state.\n\nusing Pkg\nPkg.activate(temp=true)\nPkg.add(url=\"https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl\")\nusing MolecularFingerprints\n","category":"section"},{"location":"tutorial_getting_started/#Option-2:-Project-Specific-(Recommended)","page":"Tutorial: Getting Started","title":"Option 2: Project-Specific (Recommended)","text":"Best for building reproducible research or production pipelines. This ensures your project’s dependencies are locked in a Project.toml file.\n\nusing Pkg\nPkg.activate(\".\") \nPkg.add(url=\"https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl\")\n\n\n","category":"section"},{"location":"tutorial_getting_started/#Usage","page":"Tutorial: Getting Started","title":"Usage","text":"Molecular fingerprints are essentially feature extraction steps in a pipeline. The API is designed to be functional: you define a Calculator (the model) and apply it to your Data.","category":"section"},{"location":"tutorial_getting_started/#Basic-Pipeline","page":"Tutorial: Getting Started","title":"Basic Pipeline","text":"using MolecularFingerprints\n\n# 1. Input: SMILES string (Benzene)\nsmiles = \"C1=CC=CC=C1\"\n\n# 2. This package implements 4 types of fingerprints. \n# All of them could be customized with parameters, but here we use default settings.\necfp_calc = ECFP() # Extended Connectivity Fingerprints\nmhfp_calc = MHFP() # MinHash Fingerprints\ntorsion_calc = TopologicalTorsion() # Topological Torsion Fingerprints\nmaccs_calc = MACCS() # MACCS Keys\n\n# 3. Execution: Compute the fingerprint for each type\necfp_vector = fingerprint(smiles, ecfp_calc)\nmhfp_vector = fingerprint(smiles, mhfp_calc)\ntorsion_vector = fingerprint(smiles, torsion_calc)\nmaccs_vector = fingerprint(smiles, maccs_calc)\n\n# 4. Analysis: Find indices of active features\n\n# ECFP returns BitVector to see active bits, we can use findall\nprintln(\"ECFP active bits: \", findall(ecfp_vector))\n\n# MACCS returns BitVector to see active bits, we can use findall\nprintln(\"MACCS active bits: \", findall(maccs_vector))\n\n# MHFP returns Vector{Int64} with each non-zero entry, so all bits are active\n# You will see that are of the 2048 bits are being listed\nprintln(\"MHFP active bits: \", findall(mhfp_vector .!= 0))\n\n# TopologicalTorsion returns SparseArrays.SparseVector{Int32, Int64} so it is easy to find non-zero entries\nusing SparseArrays\nprintln(\"Topological Torsion active bits: \", SparseArrays.findnz(torsion_vector)[1])\n","category":"section"},{"location":"tutorial_getting_started/#High-Throughput-Processing","page":"Tutorial: Getting Started","title":"High-Throughput Processing","text":"For large datasets, the package provides a vectorized implementation that leverages multithreading.\n\n# A list of SMILES (e.g., from a CSV)\ndataset = [\"CCO\", \"C1=CC=CC=C1\", \"CC(=O)O\"]\n\n# The vectorized call automatically parallelizes over available threads\nbatch_vectors = fingerprint(dataset, calc)\n\n\nIf you have never used molecular fingerprints before, see Explanation for an introduction to the concept. \n\nFor more detailed examples and advanced usage, please refer to the API Reference and tutorials on Solubility Prediction and Similarity Search.","category":"section"},{"location":"api_reference/#MolecularFingerprints.jl-API-Reference","page":"API Reference","title":"MolecularFingerprints.jl API Reference","text":"","category":"section"},{"location":"api_reference/#Index-of-Available-Functions-and-Types","page":"API Reference","title":"Index of Available Functions and Types","text":"","category":"section"},{"location":"api_reference/#Core-Interface","page":"API Reference","title":"Core Interface","text":"","category":"section"},{"location":"api_reference/#Type-Hierarchy","page":"API Reference","title":"Type Hierarchy","text":"","category":"section"},{"location":"api_reference/#Abstract-Types","page":"API Reference","title":"Abstract Types","text":"","category":"section"},{"location":"api_reference/#Concrete-Types","page":"API Reference","title":"Concrete Types","text":"","category":"section"},{"location":"api_reference/#Miscellaneous","page":"API Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"api_reference/#MolecularFingerprints.fingerprint","page":"API Reference","title":"MolecularFingerprints.fingerprint","text":"fingerprint(smiles::String, calc::AbstractCalculator)\n\nCalculate the fingerprint for a single SMILES string using the provided calc.\n\nArguments\n\nsmiles: A string representing the molecule in SMILES format.\ncalc: A subtype of AbstractCalculator defining the fingerprint type.\n\nReturns\n\nA fingerprint representation (the specific type depends on calc).\n\n\n\n\n\nfingerprint(mol::nothing, calc::AbstractCalculator)\n\nHandle cases where the molecule is invalid or could not be parsed.\n\nArguments\n\nmol: A nothing value indicating an invalid molecule.\ncalc: A subtype of AbstractCalculator defining the fingerprint type.\n\nReturns\n\nA default empty fingerprint based on the calculator type.\n\n\n\n\n\nfingerprint(smiles_list::Vector{String}, calc::AbstractCalculator)\n\nCalculate fingerprints for a collection of SMILES strings.\n\nThis method uses multithreading to process the list. Ensure that JULIA_NUM_THREADS is set appropriately before running the code.\n\nArguments\n\nsmiles_list: A vector of SMILES strings.\ncalc: The calculator instance to apply to each molecule.\n\nReturns\n\nVector: A collection of fingerprints, typed according to the first successful calculation.\n\nnote: Note\nThis function is thread-parallelized using Threads.@threads.\n\n\n\n\n\nfingerprint(mol::MolGraph, calc::MHFP)\n\nCalculates the MHFP fingerprint of the given molecule and returns it as a vector of UInt32's\n\n\n\n\n\nfingerprint(mol::MolGraph, calc::ECFP{N}) where N\n\nGenerate an ECFP (Extended-Connectivity Fingerprint) for a molecule.\n\nThis function implements the Morgan/ECFP algorithm as described in the original paper and matching the RDKit implementation. It generates circular fingerprints by iteratively expanding atomic neighborhoods up to the specified radius.\n\nAlgorithm Overview\n\nCompute initial atom invariants (layer 0)\nFor each layer up to the specified radius:\nExpand atomic neighborhoods by one bond\nHash neighborhood information to create new invariants\nDetect and eliminate duplicate neighborhoods\nStore unique atomic environments\nMap all environment hashes to bit positions in the fingerprint\n\nArguments\n\nmol::MolGraph: Input molecular graph\ncalc::ECFP{N}: ECFP calculator specifying radius and fingerprint size\n\nReturns\n\nBitVector: Binary fingerprint of length N with bits set for detected molecular features\n\nExamples\n\nmol = smilestomol(\"CCO\")  # Ethanol\nfp_calc = ECFP{2048}(2)   # ECFP4 with 2048 bits\nfp = fingerprint(mol, fp_calc)\n\nReferences\n\nRogers, D., & Hahn, M. (2010). Extended-connectivity fingerprints. J. Chem. Inf. Model., 50(5), 742-754.\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L257\n\n\n\n\n\nfingerprint(mol::MolGraph, calc::TopologicalTorsion)\n\nReturns a topological torsion fingerprint as an integer vector for the molecule belonging to mol.  This function calls function which computes the Topological Torsion fingerprint based on the molecular structure using paths of length pathLength.\n\nArguments\n\nmol::MolGraph: the molecule for which to calculate the fingerprint\ncalc::TopologicalTorsion: struct containing parameters for fingerprint computation, which is just the path length.   must be at least 2\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#MolecularFingerprints.AbstractCalculator","page":"API Reference","title":"MolecularFingerprints.AbstractCalculator","text":"AbstractCalculator\n\nSupertype for all molecular property calculators. Subtypes should implement  specific calculation logic for molecular properties.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.AbstractFingerprint","page":"API Reference","title":"MolecularFingerprints.AbstractFingerprint","text":"AbstractFingerprint <: AbstractCalculator\n\nAbstract type for calculators that produce representations  of molecular features (e.g., MACCS, ECFP).\n\nUnlike descriptors, fingerprints typically represent the presence or absence  of specific substructures or patterns within a molecule.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.AbstractDescriptor","page":"API Reference","title":"MolecularFingerprints.AbstractDescriptor","text":"AbstractDescriptor <: AbstractCalculator\n\nAbstract type for calculators that produce scalar or numerical molecular properties  (e.g., LogP, Molecular Weight, TPSA).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.ECFP","page":"API Reference","title":"MolecularFingerprints.ECFP","text":"ECFP{N}(radius::Int = 2)\n\nExtended-Connectivity Fingerprint (ECFP) calculator.\n\nECFPs are circular fingerprints encoding a local molecular environment around each atom up to a specified radius. This implementation closely follows the RDKit algorithm.\n\nFields\n\nradius::Int: The maximum number of bonds to traverse from each atom (default: 2)\n\nType Parameters\n\nN: The size of the fingerprint bit vector\n\nExamples\n\n# Create ECFP4 (radius=2) with 2048 bits\nfp_calc = ECFP{2048}(2)\n\n# Create ECFP6 (radius=3) with 1024 bits\nfp_calc = ECFP{1024}(3)\n\nReferences\n\nRogers, D., & Hahn, M. (2010). Extended-connectivity fingerprints. Journal of Chemical Information and Modeling, 50(5), 742-754.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.MHFP","page":"API Reference","title":"MolecularFingerprints.MHFP","text":"MHFP(;\n    radius::Int = 3,\n    min_radius::Int = 1,\n    rings::Bool = true,\n    n_permutations::Int = 2048,\n    seed::Int = 42\n)\n\nType for MHFP fingerprint calculators. Contains settings and parameters for  MHFP fingerprint generation.\n\nThe MHFP fingerprint is a vector of UInt32's, calculated for a given molecule by:\n\ngenerating the \"molecular shingling\" of the molecule, which is a set of strings,   containing:\nThe SMILES strings of all rings in the smallest set of smallest rings (sssr)   of the molecule (optional, corresponds to setting rings=true in the MHFP   calculator object),\nThe SMILES strings of the circular substructures of radii min_radius:radius around  each heavy atom of the molecule. Note: if min_radius=0, the corresponding   substructures are just the atoms themselves. \nHashing the molecular shingling, which consists of:\nConverting each string to a 32-bit integer using SHA1 (and only using the first 32  bits of the hashed result)\nApplying the MinHash scheme to the set of 32-bit integers in order to generate the   final fingerprint. The exact formula is given in the original authors paper, but  we note here that it takes a vector of 32-bit integers as input, and is furthermore  dependent on two vectors a and b, each of a given length k, which is also the length  of the resulting fingerprint vector. The two vectors are sampled at random, but  must be the same for comparable fingerprints. Note: in the fields of MHFP objects,  the vectors a, b and their length k are named _permutations_a, _permutations_b   and n_permutations, respectively.\n\nThe avaliable parameters of the calculator object are:\n\nGiven as arguments to the constructor:\n\nradius::Int: The maximum radius of circular substructures around each heavy atom    of a molecule that are to be included in the fingerprint. Typical values are 2 or 3.\nmin_radius::Int: The minimum radius of circular substructures around each heavy atom   of a molecule that are to be considered. Will be 1 in most cases, however 0 is also    valid; in this case information about the heavy atoms of the molecules is included    explicitly in the fingerprints.\nrings::Int: If true, information about rings in the molecules is included in the    fingerprints explicitly.\n\nGiven as keyword arguments to the constructor:\n\nn_permutations::Int: length of the random vectors a and b which are used in    the hashing process. Also corresponds to the length of the final fingerprint.\nseed::Int: seed for the generation of the random vectors a and b which are used    in the hashing process. Must be the same for comparable fingerprints.\n\nAlso contains the fields _mersenne_prime, _max_hash, _permutations_a and  _permutations_b, which are internal and cannot be set explicitly. The first two are constants, and the second two are random vectors which are generated  automatically based on the given seed.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.MACCS","page":"API Reference","title":"MolecularFingerprints.MACCS","text":"MACCS(count::Bool=false, sparse::Bool=false)\n\nMACCS (Molecular ACCess System) fingerprint calculator.\n\nArguments\n\ncount: If false, produces a boolean vector (presence/absence). If true, produces a count-based fingerprint.\nsparse: If false, produces a dense representation. If true, produces a sparse representation.\n\nReferences\n\nDurant et al., 2002\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.TopologicalTorsion","page":"API Reference","title":"MolecularFingerprints.TopologicalTorsion","text":"TopologicalTorsion(pathLength::Int=4)\n\nTopological Torsion fingerprint calculator.\n\nArguments\n\npathLength: Length of the paths in the molecular graph to consider (default is\n\n4).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.AccumTuple","page":"API Reference","title":"MolecularFingerprints.AccumTuple","text":"AccumTuple(;\n    bits::BitVector,\n    invariant::UInt32,\n    atom_index::Int\n)\n\nInternal structure for tracking and comparing atomic neighborhoods during ECFP generation.\n\nUsed to detect duplicate neighborhoods and maintain consistency with RDKit's algorithm by storing bond connectivity patterns along with invariant hashes.\n\nFields\n\nbits::BitVector: Bit representation of the bond neighborhood\ninvariant::UInt32: Hash invariant for this neighborhood\natom_index::Int: Index of the central atom\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.MorganAtomEnv","page":"API Reference","title":"MolecularFingerprints.MorganAtomEnv","text":"MorganAtomEnv(;\n    code::UInt32,\n    atom_id::Int,\n    layer::Int\n)\n\nInternal structure representing a Morgan atom environment.\n\nStores the hash code, atom identifier (index), and layer/radius for each atomic environment encountered during ECFP fingerprint generation.\n\nFields\n\ncode::UInt32: Hash code representing the atomic environment\natom_id::Int: Identifier of the central atom\nlayer::Int: Radius/layer at which this environment was computed\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#MolecularFingerprints.bond_order_sum-Tuple{Any, Any}","page":"API Reference","title":"MolecularFingerprints.bond_order_sum","text":"bond_order_sum(mol, v) -> Int\n\nCount sum of bond orders for atom v in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.canonicalize-Tuple{Vector}","page":"API Reference","title":"MolecularFingerprints.canonicalize","text":"canonicalize(path::Vector{Int})\n\nArguments\n\npath::Vector: Vertex indices of a cycle from the molecular graph\n\nCanonicalization is done to obtain unique fingerprints for different smiles strings as described in https://depth-first.com/articles/2021/10/06/molecular-graph-canonicalization/.   Since every ring is found pathLength times, we have to abandon all but one ring.   We only keep the ring which starts at the lowest numbered vertex.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.count_CH3-Tuple{Any}","page":"API Reference","title":"MolecularFingerprints.count_CH3","text":"count_CH3(mol) -> Int\n\nCount how many CH3 groups are in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.count_atom-Tuple{Any, Symbol}","page":"API Reference","title":"MolecularFingerprints.count_atom","text":"count_atom(mol, sym::Symbol) -> Int\n\nCount how many atoms (sym::Symbol) are in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}","page":"API Reference","title":"MolecularFingerprints.ecfp_atom_invariant","text":"ecfp_atom_invariant(smiles::AbstractString)\necfp_atom_invariant(mol::AbstractMolGraph)\necfp_atom_invariant(mol::AbstractMolGraph, atom_index)\n\nCalculate atomic invariants for ECFP fingerprint generation.\n\nThe atomic invariants are properties of an atom that don't depend on initial atom numbering, based on the Daylight atomic invariants. This implementation follows the RDKit approach.\n\nArguments\n\nsmiles::AbstractString: SMILES string representation of a molecule\nmol::AbstractMolGraph: Molecular graph structure\natom_index: Index of the specific atom to compute invariants for. If not specified, invariants for all atoms are computed and returned\n\nReturns\n\nFor single atom: Vector{UInt32} containing the invariant components\nFor all atoms: Vector{Vector{UInt32}} with invariants for each atom\n\nInvariant Components\n\nThe computed invariants include (in order):\n\nAtomic number\nTotal degree (number of neighbors including implicit hydrogens)\nTotal number of hydrogens (implicit + explicit)\nAtomic charge\nDelta mass (difference from standard isotope mass)\nRing membership indicator (1 if atom is in a ring, omitted otherwise)\n\nReferences\n\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/FingerprintUtil.cpp#L244\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}","page":"API Reference","title":"MolecularFingerprints.ecfp_hash","text":"ecfp_hash(v::Vector{UInt32})\n\nGenerate a hash value from a vector of UInt32 values.\n\nIteratively combines all values in the vector using the ECFP hash combining algorithm to produce a single hash value representing the entire vector.\n\nArguments\n\nv::Vector{UInt32}: Vector of values to hash\n\nReturns\n\nUInt32: Hash value representing the input vector\n\nReferences\n\nBoost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/RDGeneral/hash/hash.hpp\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}","page":"API Reference","title":"MolecularFingerprints.ecfp_hash_combine","text":"ecfp_hash_combine(seed::UInt32, value::UInt32)\n\nCombine two hash values using the boost hash_combine algorithm.\n\nThis function implements the hash combining strategy used in RDKit's ECFP implementation, which is based on the boost C++ library's hash_combine function.\n\nArguments\n\nseed::UInt32: Current hash seed value\nvalue::UInt32: New value to combine into the hash\n\nReturns\n\nUInt32: Combined hash value\n\nReferences\n\nBoost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/RDGeneral/hash/hash.hpp\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}","page":"API Reference","title":"MolecularFingerprints.getAtomCode","text":"getAtomCode(degree::Int, piBond::Int, atomicNumber::Int)\n\nCalculates an integer for an atom of a molecule from number of non-hydrogen branches, number of pi bonds and atomic number\n\nArguments\n\ndegree::Int: number of non-hydrogen branches\npiBond::Int: number of pi bonds\natomicNumber::Int: atomic number\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}","page":"API Reference","title":"MolecularFingerprints.getPathsOfLengthN","text":"getPathsOfLengthN(mol::MolGraph, N::Int)\n\nReturns a list of all simple paths of length N and cycles of length N - 1 in the Molecular Graph.\n\nArguments\n\nmol::MolGraph: the molecule from which to extract the walks\nN::Int: length of the walks, meaning number of vertices in walk\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.getTTFPCode-Tuple{Vector}","page":"API Reference","title":"MolecularFingerprints.getTTFPCode","text":"getTTFPCode(pathCodes::Vector)\n\nCalculates an integer from a number calculated from the atom codes of a path which will serve  as an index for which the fingerprint will be increased by 1.\n\nArguments\n\npathCodes::Vector: contains a code generated from the atom codes of molecules of a path\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}","page":"API Reference","title":"MolecularFingerprints.getTopologicalTorsionFP","text":"getTopologicalTorsionFP(mol::MolGraph, pathLength::Int)\n\nReturns the Topological Torsion Fingerprint of a molecule as a sparse Int Vector. This function loops over all simple paths of length pathLength and all cycles of length pathLength - 1 of the molecular graph,  and gets a number for each atom in a path, an \"Atom Code\" from which a sparse IntVector is calculated.\n\nArguments\n\nmol::MolGraph: the molecule for which to calculate the fingerprint\npathLength::Int: length of walks from molecular graph used to calculated fingerprint\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.MolGraph}","page":"API Reference","title":"MolecularFingerprints.get_atom_invariants","text":"get_atom_invariants(mol::MolGraph)\n\nCompute hashed atom invariants for all atoms in a molecule.\n\nArguments\n\nmol::MolGraph: Input molecular graph\n\nReturns\n\nVector{UInt32}: Hashed invariant values for each atom\n\nReferences\n\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L42\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.MolGraph}","page":"API Reference","title":"MolecularFingerprints.get_bond_invariants","text":"get_bond_invariants(mol::MolGraph)\n\nCompute bond type invariants for all bonds in a molecule.\n\nArguments\n\nmol::MolGraph: Input molecular graph\n\nReturns\n\nVector{UInt32}: Bond type codes for each bond in the molecule\n\nKnown Issue\n\nThe edge properties provided by MolecularGraph.jl are not in the same order as in RDKit. This results in different hashes and, ultimately, in different fingerprints for larger molecules compared to RDKit. As this would require rework on the smilestomol algorithm provided by MolecularGraph.jl, a fix for this issue is currently not in scope of this project.\n\nReferences\n\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L126\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_NH-Tuple{Any}","page":"API Reference","title":"MolecularFingerprints.has_NH","text":"has_NH(mol) -> Bool\n\nCheck whether molecule (mol) has NH group\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_OH-Tuple{Any}","page":"API Reference","title":"MolecularFingerprints.has_OH","text":"has_OH(mol) -> Bool\n\nCheck whether molecule (mol) has OH group\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_any_bond-Tuple{Any, Symbol, Symbol}","page":"API Reference","title":"MolecularFingerprints.has_any_bond","text":"has_any_bond(mol, s1::Symbol, s2::Symbol)-> Bool\n\nN~S - check whether there is at least one bond between atoms (s1::Symbol, s2::Symbol) in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_atom-Tuple{Any, Symbol}","page":"API Reference","title":"MolecularFingerprints.has_atom","text":"has_atom(mol, sym::Symbol) -> Bool\n\nCheck whether atom (sym::Symbol) is contained in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_atom_in_set-Tuple{Any, Set{Symbol}}","page":"API Reference","title":"MolecularFingerprints.has_atom_in_set","text":"has_atom_in_set(mol, syms::Set{Symbol}) -> Bool\n\nCheck whether at least one atom of molecule (mol) is in set of atoms (syms::Set{Symbol})    \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_bond-Tuple{Any, Symbol, Symbol, Int64}","page":"API Reference","title":"MolecularFingerprints.has_bond","text":"has_bond(mol, s1::Symbol, s2::Symbol, order::Int) -> Bool\n\nCheck whether a bond exists between atoms (s1::Symbol, s2::Symbol) with given order in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_path3-Tuple{Any, Symbol, Symbol, Symbol}","page":"API Reference","title":"MolecularFingerprints.has_path3","text":"has_path3(mol, s1::Union{Symbol}, s2::Union{Symbol}, s3::Union{Symbol}) -> Bool\n\nA~B~C - check whether there is a path of length 3 between atoms (s1::Symbol, s2::Symbol, s3::Symbol) in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_ring-Tuple{Any}","page":"API Reference","title":"MolecularFingerprints.has_ring","text":"has_ring(mol) -> Bool\n\nCheck whether molecule (mol) has at least one ring\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_ring_of_size-Tuple{Any, Int64}","page":"API Reference","title":"MolecularFingerprints.has_ring_of_size","text":"has_ring_of_size(mol, n::Int) -> Bool\n\nCheck whether molecule (mol) has a ring of given size (n::Int)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.has_strict_path3-Tuple{Any, Symbol, Nothing, Symbol}","page":"API Reference","title":"MolecularFingerprints.has_strict_path3","text":"has_strict_path3(mol, s1::Symbol, s2::Nothing, s3::Symbol) -> Bool\n\nA~X~C - check whether there is a path of length 3 between atoms (s1::Symbol, s3::Symbol) in molecule (mol), where X can be any atom\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.internal_implicit_hydrogens-Tuple{Any, Any}","page":"API Reference","title":"MolecularFingerprints.internal_implicit_hydrogens","text":"internal_implicit_hydrogens(mol, v) -> Int\n\nCount how many implicit (invisible) hydrogens atom v has in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.is_CH2-Tuple{Any, Any}","page":"API Reference","title":"MolecularFingerprints.is_CH2","text":"is_CH2(mol, v) -> Bool\n\nCheck wheter atom v is in group CH2 in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.is_CH3-Tuple{Any, Any}","page":"API Reference","title":"MolecularFingerprints.is_CH3","text":"is_CH3(mol, v) -> Bool\n\nCheck wheter atom v is in group CH3 in molecule (mol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.max_valence-Tuple{Symbol}","page":"API Reference","title":"MolecularFingerprints.max_valence","text":"max_valence(sym::Symbol) -> Int\n\nReturns valence for given atom symbol (sym::Symbol)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}","page":"API Reference","title":"MolecularFingerprints.mhfp_hash_from_molecular_shingling","text":"mhfp_hash_from_molecular_shingling(shingling::Vector{String}, calc::MHFP)\n\nCalculate the MinHash values from a given Molecular shingling.\n\nThe given calculator contains parameters such as the length of the random vectors a , b that are used in the hashing scheme, as well as the seed used when generating them. The algorithm is described in more detail in the original authors paper.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.mhfp_shingling_from_mol!-Tuple{MolecularGraph.MolGraph, MHFP}","page":"API Reference","title":"MolecularFingerprints.mhfp_shingling_from_mol!","text":"mhfp_shingling_from_mol!(\n    mol::MolGraph,\n    calc::MHFP)\n\nCalculate the \"molecular shingling\" of a given molecule.\n\nA molecular shingling is a vector of \"SMILES\"-strings, calculated from the ring  structures and atom types of the molecule (optional), and the circular substructures  around each heavy (=non-hydrogen) atom of the molecule.\n\nArguments\n\nmol::MolGraph: the molecule for which to calculate the shingling.\ncalc::MHFP: fingeprint \"calculator\" object, containing the relevant parameters for the    fingerprint calculation, e.g., the radii of the circular substructures to be considered   and whether to include ring information explicitly in the fingerprints\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.nonH_neighbors-Tuple{Any, Any}","page":"API Reference","title":"MolecularFingerprints.nonH_neighbors","text":"nonH_neighbors(mol, v) -> Vector{Int}\n\nGet neighbors of atom v in molecule (mol) which are NOT hydrogen\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}","page":"API Reference","title":"MolecularFingerprints.rdkit_bond_type","text":"rdkit_bond_type(bond::SMILESBond)\n\nConvert a SMILES bond to RDKit's bond type encoding.\n\nMaps bond properties to integer codes matching RDKit's bond type enumeration.\n\nArguments\n\nbond::SMILESBond: Input bond object\n\nReturns\n\nInt: Bond type code (1-6 for single to hextuple, 12 for aromatic, 20 for other, 21 for zero)\n\nKnown Issues\n\nDue to differences in the internal representation of bonds within MolecularGraph.jl, we currently only support the most common bond types (1 to 6).\n\nReferences\n\nRDKit bond types: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Bond.h#L55\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.safe_atom_symbol-Tuple{Any}","page":"API Reference","title":"MolecularFingerprints.safe_atom_symbol","text":"safe_atom_symbol(atom)\n\nReturns the atom symbol as a Symbol type (:C) not string (\"C\")\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.safe_smilestomol-Tuple{String}","page":"API Reference","title":"MolecularFingerprints.safe_smilestomol","text":"safe_smilestomol(smiles::String)\n\nAttempts to parse a SMILES string. Returns nothing if it fails instead of crashing the entire thread.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}","page":"API Reference","title":"MolecularFingerprints.smiles_from_atoms","text":"smiles_from_atoms(mol::MolGraph)\n\nReturn vector containing SMILES strings of all atoms of the given molecule.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}","page":"API Reference","title":"MolecularFingerprints.smiles_from_circular_substructures","text":"smiles_from_circular_substructures(\n    mol::MolGraph,\n    radius::Int,\n    min_radius::Int)\n\nReturn vector of SMILES strings of circular substructures around all atoms of a molecule.\n\nFor each atom of the given molecule, extract the substructures of radii min_radius to radius, and generate their corresponding SMILES strings.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}","page":"API Reference","title":"MolecularFingerprints.smiles_from_rings","text":"smiles_from_rings(mol::MolGraph)\n\nReturn vector containing SMILES strings of all rings in the SSSR of the given molecule.\n\nSSSR stands for the smallest set of smallest rings of the molecule.\n\nNote: This function uses the function sssr from MolecularGraph.jl, which returns a \"true\" smallest set of smallest rings of the given molecule. However, in the original implementation of the mhfp algorithm, the \"symmetrisized sssr\" is used, which in some cases is non-minimal, i.e., contains an additional ring. The rdkit function to get the symmetrisized sssr is not available in MolecularGraph.jl or in RDKitMinimalLib, which is why the standard sssr is used. In most cases, this will not have any effect, but for some molecules, such as cubane, it  will.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.smiles_to_neutralized_mol-Tuple{String}","page":"API Reference","title":"MolecularFingerprints.smiles_to_neutralized_mol","text":"smiles_to_neutralized_mol(smiles_string::String)\n\nConvert a SMILES string to a neutralized MolGraph instance. This function identifies the largest fragment in the SMILES string, removes charges from common organic elements, and returns the corresponding MolGraph.\n\nArguments\n\nsmiles_string: A string representing the molecule in SMILES format.\n\nReturns\n\nA MolGraph instance of the neutralized largest fragment.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#MolecularFingerprints.tanimoto_similarity-Tuple{BitVector, BitVector}","page":"API Reference","title":"MolecularFingerprints.tanimoto_similarity","text":"tanimoto_similarity(a::BitVector, b::BitVector)\n\nCalculate the tanimoto_similarity similarity coefficient (Jaccard Index) between two fingerprints. Formula: c / (a + b - c) where c is intersection count.\n\n\n\n\n\n","category":"method"},{"location":"tutorial_solubility_prediction/#QSAR-Pipeline:-Solubility-Prediction","page":"Tutorial: Solubility Prediction","title":"QSAR Pipeline: Solubility Prediction","text":"In this tutorial, we will build a Random Forest model to predict the aqueous solubility of molecules using MolecularFingerprints.jl and DecisionTree.jl.","category":"section"},{"location":"tutorial_solubility_prediction/#1.-Setup-and-Data-Loading","page":"Tutorial: Solubility Prediction","title":"1. Setup and Data Loading","text":"We will use a small subset of the Delaney (ESOL) dataset. For this demo, we mock the data loading, but you would normally use CSV.read.\n\nusing Random\nusing Statistics\nusing DecisionTree\nusing MolecularFingerprints\nusing MolecularGraph\n\n# For reproducibility\nseed!(42)\n\n# Small subset of the Delaney Solubility Dataset (SMILES, Measured LogS)\ndata = [\n    (\"CCO\", 0.8),               # Ethanol (High solubility)\n    (\"CC(=O)Oc1ccccc1C(=O)O\", -2.1), # Aspirin (Moderate)\n    (\"c1ccccc1\", -2.0),         # Benzene (Low)\n    (\"CCCCCCCC\", -4.5),         # Octane (Very Low)\n    (\"O=C(C)Oc1ccccc1C(=O)O\", -2.2), # Aspirin analog\n    (\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\", -0.9) # Caffeine\n]\n\n# Separate X (SMILES) and y (Labels)\nsmiles_list = [d[1] for d in data]\ny = [d[2] for d in data]","category":"section"},{"location":"tutorial_solubility_prediction/#2.-Feature-Generation-(Fingerprinting)","page":"Tutorial: Solubility Prediction","title":"2. Feature Generation (Fingerprinting)","text":"We convert the raw SMILES strings into fixed-length numeric vectors using ECFP4.\n\n# Parse SMILES to GraphMol objects\nmols = [smilestomol(s) for s in smiles_list]\n\n# Define the featurizer\nfeaturizer_ecfp = ECFP{2}(2) # 2048-bit ECFP with radius 2\nfeaturizer_maccs = MACCS(true, false) # MACCS keys\n\n# Generate BitVectors\n# Note: DecisionTree.jl expects a standard Matrix{Float64} or Matrix{Int}\nfingerprints = [fingerprint(m, featurizer_ecfp) for m in mols]\n# Convert Vector of BitVectors to a Matrix (Samples x Features)\n# We transpose (') because hcat stacks them as columns\nX = hcat(fingerprints...)'\nX = Matrix(X) # Convert to standard dense matrix for ML","category":"section"},{"location":"tutorial_solubility_prediction/#3.-Model-Training","page":"Tutorial: Solubility Prediction","title":"3. Model Training","text":"# Train/Test Split (Simple 80/20 manual split for demo)\nn_samples = length(y)\ntrain_idx = shuffle(1:n_samples)[1:floor(Int, 0.8*n_samples)]\ntest_idx = setdiff(1:n_samples, train_idx)\n\nX_train, y_train = X[train_idx, :], y[train_idx]\nX_test, y_test = X[test_idx, :], y[test_idx]\n\n# Initialize and Train Model\n# n_trees=10, min_samples=2\nmodel = build_forest(y_train, X_train, 2, 10, 0.7, -1)\n\nprintln(\"Model Trained successfully!\")","category":"section"},{"location":"tutorial_solubility_prediction/#4.-Model-Evaluation","page":"Tutorial: Solubility Prediction","title":"4. Model Evaluation","text":"# Predict on Test Set\npreds = apply_forest(model, X_test)\nrmse = sqrt(mean((preds .- y_test).^2))\n\nprintln(\"Test RMSE: $rmse\")\n\n# Inference on New Molecule\nnew_mol_smiles = \"CC(=O)N\" # Acetamide\nnew_mol = smilestomol(new_mol_smiles)\nnew_fp = fingerprint(new_mol, featurizer_ecfp)\n\n# Reshape to 1xN Matrix for prediction\nnew_X = reshape(new_fp, 1, length(new_fp))\n\npredicted_solubility = apply_forest(model, new_X)[1]\nprintln(\"Predicted Solubility for $new_mol_smiles: $predicted_solubility\")","category":"section"},{"location":"validation/#Validation-and-Testing","page":"Validation & Testing","title":"Validation & Testing","text":"How do we know if our implementation is good?","category":"section"},{"location":"validation/#1.-Validation-Strategy-Cross-Library-Testing","page":"Validation & Testing","title":"1. Validation Strategy -> Cross-Library Testing","text":"When developing fingerprinting algorithms, we compare our results against industry standards like RDKit (C++). However, direct bit-vector comparison is not a valid test for correctness due to implementation details:\n\nHashing Variance: Our native Julia implementation utilizes the internal hash() function, whereas RDKit uses specific PRNG (Pseudo-Random Number Generator) seeds in C++.\nResult: The specific indices of bits set will differ between libraries.","category":"section"},{"location":"validation/#Verification-via-Ranking-Correlation","page":"Validation & Testing","title":"Verification via Ranking Correlation","text":"Instead of bitwise equality, we validate using Statistical Correlation. If the chemical logic (subgraph extraction) is identical, the Tanimoto similarity between pairs of molecules should be highly correlated across both libraries.\n\nWe verify that if Molecule A is \"most similar\" to Molecule B in RDKit, MolecularFingerprints.jl should produce the same ranking order, even if the underlying bit-vectors are different.","category":"section"},{"location":"validation/#2.-Testing-Framework","page":"Validation & Testing","title":"2. Testing Framework","text":"We use the standard Julia Test module to ensure high code coverage and functional correctness.","category":"section"},{"location":"validation/#Running-Tests","page":"Validation & Testing","title":"Running Tests","text":"The most efficient way to run tests is via the Julia REPL. From the root of the repository:\n\n# Method 1: The standard Pkg way (Recommended)\npkg> activate .\npkg> test\n\n# Method 2: Running the test script directly from terminal\n# julia --project=test test/runtests.jl\n","category":"section"},{"location":"validation/#Managing-the-Test-Environment","page":"Validation & Testing","title":"Managing the Test Environment","text":"The tests reside in an independent environment located in the /test directory. This keeps the main package dependencies lightweight by excluding testing-only packages (like RDKitMinimalLib) from the production environment.\n\nAdding a new test-only dependency:\n\npkg> activate test\npkg> add Statistics  # Example: adding a stats package for validation\n\n\nSyncing your local changes for testing: If you make changes to the source code in /src, ensure the test environment is tracking your local version:\n\npkg> activate test\npkg> dev . \n","category":"section"},{"location":"validation/#CI-Integration","page":"Validation & Testing","title":"CI Integration","text":"Every Pull Request is automatically tested against multiple Julia versions and operating systems via GitHub Actions. We also track Code Coverage; please ensure that any new fingerprint types added include corresponding tests in test/runtests.jl.","category":"section"},{"location":"#MolecularFingerprints","page":"Home","title":"MolecularFingerprints","text":"Welcome to the documentation for MolecularFingerprints.jl - a Julia package for calculating molecular fingerprints.\n\nFrom here you can view:\n\nExplanation — An explanation of what molecular fingerprints are and why they are useful.\nTutorial: Getting Started — A tutorial on how to install and use the MolecularFingerprints.jl package.\nTutorial: Solubility Prediction — A tutorial on using molecular fingerprints for predicting solubility.\nTutorial: Similarity Search — A tutorial on performing similarity searches using molecular fingerprints.\nFingerprint Types — A detailed overview of the different types of molecular fingerprints implemented in the package.\nAPI Reference — The complete API reference for the MolecularFingerprints.jl package.\nDeveloper Guide — A guide for developers interested in contributing to the MolecularFingerprints.jl package.\nValidation & Testing — Information on how the package is validated and tested.\nBest Practices — Recommendations and best practices for using molecular fingerprints effectively.\nFAQ — Frequently Asked Questions about molecular fingerprints and the MolecularFingerprints.jl package.","category":"section"},{"location":"developer_guide/#Developer-Guide","page":"Developer Guide","title":"Developer Guide","text":"Thank you for contributing to MolecularFingerprints.jl. This guide outlines the technical workflow for setting up your local environment, managing dependencies, and validating your changes.","category":"section"},{"location":"developer_guide/#Engineering-Standards","page":"Developer Guide","title":"Engineering Standards","text":"Before opening a Pull Request (PR), please review our CONTRIBUTING.md.","category":"section"},{"location":"developer_guide/#Local-Environment-Setup","page":"Developer Guide","title":"Local Environment Setup","text":"To modify the source code, you must clone the repository and instantiate its dependencies. This ensures your local environment exactly matches the project's Manifest.toml.\n\n# Clone the repository\ngit clone https://github.com/LukaszSztukiewicz/MolecularFingerprints.jl\ncd MolecularFingerprints.jl\n\n# Launch Julia with the project environment active\njulia --project=.\n\n\nInside the Julia REPL, synchronize your environment:\n\nusing Pkg\nPkg.instantiate()  # Downloads all dependencies specified in Project.toml\n","category":"section"},{"location":"developer_guide/#Testing","page":"Developer Guide","title":"Testing","text":"We use the standard Julia Test library. Our test suite is located in the test/ directory.","category":"section"},{"location":"developer_guide/#Running-Tests","page":"Developer Guide","title":"Running Tests","text":"There are two primary ways to run the suite. The first is preferred for rapid iteration:\n\nFrom the REPL (Active Development):\n\npkg> test\n\n\nFrom the Terminal (CI Emulation):\n\njulia --project -e 'using Pkg; Pkg.test()'\n","category":"section"},{"location":"developer_guide/#Managing-Test-Dependencies","page":"Developer Guide","title":"Managing Test Dependencies","text":"The tests reside in their own environment (test/Project.toml). If your new tests require a new package (e.g., BenchmarkTools):\n\npkg> activate test\npkg> add BenchmarkTools\npkg> dev .  # Ensure the test environment points to the local source code\n","category":"section"},{"location":"developer_guide/#Documentation-Workflow","page":"Developer Guide","title":"Documentation Workflow","text":"Documentation is built using Documenter.jl. To preview your changes to docstrings or .md files locally, use the provided build script.","category":"section"},{"location":"developer_guide/#Building-Locally","page":"Developer Guide","title":"Building Locally","text":"Enter the docs environment:\n\njulia --project=docs/\n\n\nRun the build script:\n\nusing Pkg\nPkg.instantiate()\ninclude(\"docs/make.jl\")\n\n\nThis generates the HTML files in docs/build/. Open index.html in your browser to preview.","category":"section"},{"location":"developer_guide/#Continuous-Integration-(CI)","page":"Developer Guide","title":"Continuous Integration (CI)","text":"When you push a branch to GitHub, our GitHub Actions pipeline automatically triggers:\n\nUnit Tests: Executed across multiple Julia versions (current stable and LTS) and OS platforms (Linux, macOS, Windows).\nCode Coverage: Reports are sent to Codecov to ensure no regressions in test coverage.\nDocumentation Preview: A temporary version of the docs is built to verify formatting.","category":"section"},{"location":"developer_guide/#Updating-Dependencies","page":"Developer Guide","title":"Updating Dependencies","text":"If you need to update the package dependencies to a newer version:\n\npkg> activate .\npkg> update\npkg> activate test\npkg> update\n\n\nAlways commit the updated Manifest.toml files to ensure other developers stay in sync.","category":"section"}]
}
