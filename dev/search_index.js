var documenterSearchIndex = {"docs":
[{"location":"getting_started/#QSAR-Pipeline:-Solubility-Prediction","page":"Getting Started","title":"QSAR Pipeline: Solubility Prediction","text":"In this tutorial, we will build a Random Forest model to predict the aqueous solubility of molecules using MolecularFingerprints.jl and DecisionTree.jl.","category":"section"},{"location":"getting_started/#1.-Setup-and-Data-Loading","page":"Getting Started","title":"1. Setup and Data Loading","text":"We will use a small subset of the Delaney (ESOL) dataset. For this demo, we mock the data loading, but you would normally use CSV.read.\n\nusing Random\nusing Statistics\nusing DecisionTree\nusing MolecularFingerprints\nusing MolecularGraph\n\n# For reproducibility\nRandom.seed!(42)\n\n# Small subset of the Delaney Solubility Dataset (SMILES, Measured LogS)\ndata = [\n    (\"CCO\", 0.8),               # Ethanol (High solubility)\n    (\"CC(=O)Oc1ccccc1C(=O)O\", -2.1), # Aspirin (Moderate)\n    (\"c1ccccc1\", -2.0),         # Benzene (Low)\n    (\"CCCCCCCC\", -4.5),         # Octane (Very Low)\n    (\"O=C(C)Oc1ccccc1C(=O)O\", -2.2), # Aspirin analog\n    (\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\", -0.9) # Caffeine\n]\n\n# Separate X (SMILES) and y (Labels)\nsmiles_list = [d[1] for d in data]\ny = [d[2] for d in data]","category":"section"},{"location":"getting_started/#2.-Feature-Generation-(Fingerprinting)","page":"Getting Started","title":"2. Feature Generation (Fingerprinting)","text":"We convert the raw SMILES strings into fixed-length numeric vectors using ECFP4.\n\n# Parse SMILES to GraphMol objects\nmols = [smilestomol(s) for s in smiles_list]\n\n# Define the featurizer\nfeaturizer_ecfp = ECFP{2}(2) # 2048-bit ECFP with radius 2\nfeaturizer_maccs = MACCSFingerprint(true, false) # MACCS keys\n\n# Generate BitVectors\n# Note: DecisionTree.jl expects a standard Matrix{Float64} or Matrix{Int}\nfingerprints = [fingerprint(m, featurizer_ecfp) for m in mols]\n# Convert Vector of BitVectors to a Matrix (Samples x Features)\n# We transpose (') because hcat stacks them as columns\nX = hcat(fingerprints...)'\nX = Matrix(X) # Convert to standard dense matrix for ML","category":"section"},{"location":"getting_started/#3.-Model-Training","page":"Getting Started","title":"3. Model Training","text":"# Train/Test Split (Simple 80/20 manual split for demo)\nn_samples = length(y)\ntrain_idx = shuffle(1:n_samples)[1:floor(Int, 0.8*n_samples)]\ntest_idx = setdiff(1:n_samples, train_idx)\n\nX_train, y_train = X[train_idx, :], y[train_idx]\nX_test, y_test = X[test_idx, :], y[test_idx]\n\n# Initialize and Train Model\n# n_trees=10, min_samples=2\nmodel = build_forest(y_train, X_train, 2, 10, 0.7, -1)\n\nprintln(\"Model Trained successfully!\")","category":"section"},{"location":"getting_started/#4.-Model-Evaluation","page":"Getting Started","title":"4. Model Evaluation","text":"# Predict on Test Set\npreds = apply_forest(model, X_test)\nrmse = sqrt(mean((preds .- y_test).^2))\n\nprintln(\"Test RMSE: $rmse\")\n\n# Inference on New Molecule\nnew_mol_smiles = \"CC(=O)N\" # Acetamide\nnew_mol = smilestomol(new_mol_smiles)\nnew_fp = fingerprint(new_mol, featurizer_ecfp)\n\n# Reshape to 1xN Matrix for prediction\nnew_X = reshape(new_fp, 1, length(new_fp))\n\npredicted_solubility = apply_forest(model, new_X)[1]\nprintln(\"Predicted Solubility for $new_mol_smiles: $predicted_solubility\")","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"Since our native Julia implementation uses Julia's hash() function, the specific bits set will differ from RDKit's C++ implementation (which uses specific random seeds). Therefore, strict bitwise equality (==) is impossible to test.\n\nInstead, we validate by Ranking Correlation: We verify that MolecularFingerprints.jl identifies the same molecules as \"similar\" that RDKit does. If the chemical logic is correct, the Tanimoto similarity scores for a set of molecules should be highly correlated between the two libraries.","category":"section"},{"location":"#MolecularFingerprints","page":"Home","title":"MolecularFingerprints","text":"Documentation for MolecularFingerprints.\n\n","category":"section"},{"location":"#MolecularFingerprints.MHFP","page":"Home","title":"MolecularFingerprints.MHFP","text":"MHFP{N}\n\nClass for MHFP fingerprint generator/featurizer. Contains settings and parameters for  MHFP fingerprint generation.\n\n\n\n\n\n","category":"type"},{"location":"#MolecularFingerprints.fingerprint-Union{Tuple{N}, Tuple{MolecularGraph.SMILESMolGraph, MHFP{N}}} where N","page":"Home","title":"MolecularFingerprints.fingerprint","text":"fingerprint(mol::SMILESMolGraph, calc::MHFP{N})\n\nCalculates the MHFP fingerprint of the given molecule and returns it as a bit vector\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.mhfp_shingling_from_mol-Tuple{MolecularGraph.SMILESMolGraph}","page":"Home","title":"MolecularFingerprints.mhfp_shingling_from_mol","text":"mhfp_shingling_from_mol(mol)\n\nCalculates the \"shingling\" (a \"SMILES\"-string containing the circular substructures around each atom of the molecule) of a given molecule, given as MolecularGraph.Mol object\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.tanimoto-Tuple{BitVector, BitVector}","page":"Home","title":"MolecularFingerprints.tanimoto","text":"tanimoto(a::BitVector, b::BitVector) -> Float64\n\nCalculate the Tanimoto similarity coefficient (Jaccard Index) between two fingerprints. Formula: c / (a + b - c) where c is intersection count.\n\n\n\n\n\n","category":"method"}]
}
