var documenterSearchIndex = {"docs":
[{"location":"getting_started/#QSAR-Pipeline:-Solubility-Prediction","page":"Getting Started","title":"QSAR Pipeline: Solubility Prediction","text":"In this tutorial, we will build a Random Forest model to predict the aqueous solubility of molecules using MolecularFingerprints.jl and DecisionTree.jl.","category":"section"},{"location":"getting_started/#1.-Setup-and-Data-Loading","page":"Getting Started","title":"1. Setup and Data Loading","text":"We will use a small subset of the Delaney (ESOL) dataset. For this demo, we mock the data loading, but you would normally use CSV.read.\n\nusing Random\nusing Statistics\nusing DecisionTree\nusing MolecularFingerprints\nusing MolecularGraph\n\n# For reproducibility\nRandom.seed!(42)\n\n# Small subset of the Delaney Solubility Dataset (SMILES, Measured LogS)\ndata = [\n    (\"CCO\", 0.8),               # Ethanol (High solubility)\n    (\"CC(=O)Oc1ccccc1C(=O)O\", -2.1), # Aspirin (Moderate)\n    (\"c1ccccc1\", -2.0),         # Benzene (Low)\n    (\"CCCCCCCC\", -4.5),         # Octane (Very Low)\n    (\"O=C(C)Oc1ccccc1C(=O)O\", -2.2), # Aspirin analog\n    (\"CN1C=NC2=C1C(=O)N(C(=O)N2C)C\", -0.9) # Caffeine\n]\n\n# Separate X (SMILES) and y (Labels)\nsmiles_list = [d[1] for d in data]\ny = [d[2] for d in data]","category":"section"},{"location":"getting_started/#2.-Feature-Generation-(Fingerprinting)","page":"Getting Started","title":"2. Feature Generation (Fingerprinting)","text":"We convert the raw SMILES strings into fixed-length numeric vectors using ECFP4.\n\n# Parse SMILES to GraphMol objects\nmols = [smilestomol(s) for s in smiles_list]\n\n# Define the featurizer\nfeaturizer_ecfp = ECFP{2}(2) # 2048-bit ECFP with radius 2\nfeaturizer_maccs = MACCSFingerprint(true, false) # MACCS keys\n\n# Generate BitVectors\n# Note: DecisionTree.jl expects a standard Matrix{Float64} or Matrix{Int}\nfingerprints = [fingerprint(m, featurizer_ecfp) for m in mols]\n# Convert Vector of BitVectors to a Matrix (Samples x Features)\n# We transpose (') because hcat stacks them as columns\nX = hcat(fingerprints...)'\nX = Matrix(X) # Convert to standard dense matrix for ML","category":"section"},{"location":"getting_started/#3.-Model-Training","page":"Getting Started","title":"3. Model Training","text":"# Train/Test Split (Simple 80/20 manual split for demo)\nn_samples = length(y)\ntrain_idx = shuffle(1:n_samples)[1:floor(Int, 0.8*n_samples)]\ntest_idx = setdiff(1:n_samples, train_idx)\n\nX_train, y_train = X[train_idx, :], y[train_idx]\nX_test, y_test = X[test_idx, :], y[test_idx]\n\n# Initialize and Train Model\n# n_trees=10, min_samples=2\nmodel = build_forest(y_train, X_train, 2, 10, 0.7, -1)\n\nprintln(\"Model Trained successfully!\")","category":"section"},{"location":"getting_started/#4.-Model-Evaluation","page":"Getting Started","title":"4. Model Evaluation","text":"# Predict on Test Set\npreds = apply_forest(model, X_test)\nrmse = sqrt(mean((preds .- y_test).^2))\n\nprintln(\"Test RMSE: $rmse\")\n\n# Inference on New Molecule\nnew_mol_smiles = \"CC(=O)N\" # Acetamide\nnew_mol = smilestomol(new_mol_smiles)\nnew_fp = fingerprint(new_mol, featurizer_ecfp)\n\n# Reshape to 1xN Matrix for prediction\nnew_X = reshape(new_fp, 1, length(new_fp))\n\npredicted_solubility = apply_forest(model, new_X)[1]\nprintln(\"Predicted Solubility for $new_mol_smiles: $predicted_solubility\")","category":"section"},{"location":"testing/","page":"Testing","title":"Testing","text":"Since our native Julia implementation uses Julia's hash() function, the specific bits set will differ from RDKit's C++ implementation (which uses specific random seeds). Therefore, strict bitwise equality (==) is impossible to test.\n\nInstead, we validate by Ranking Correlation: We verify that MolecularFingerprints.jl identifies the same molecules as \"similar\" that RDKit does. If the chemical logic is correct, the Tanimoto similarity scores for a set of molecules should be highly correlated between the two libraries.","category":"section"},{"location":"#MolecularFingerprints","page":"Home","title":"MolecularFingerprints","text":"Documentation for MolecularFingerprints.\n\n","category":"section"},{"location":"#MolecularFingerprints.AccumTuple","page":"Home","title":"MolecularFingerprints.AccumTuple","text":"AccumTuple\n\nInternal structure for tracking and comparing atomic neighborhoods during ECFP generation.\n\nUsed to detect duplicate neighborhoods and maintain consistency with RDKit's algorithm by storing bond connectivity patterns along with invariant hashes.\n\nFields\n\nbits::BitVector: Bit representation of the bond neighborhood\ninvariant::UInt32: Hash invariant for this neighborhood\natom_index::Int: Index of the central atom\n\n\n\n\n\n","category":"type"},{"location":"#MolecularFingerprints.ECFP","page":"Home","title":"MolecularFingerprints.ECFP","text":"ECFP{N} <: AbstractFingerprint\n\nExtended-Connectivity Fingerprint (ECFP) calculator.\n\nECFPs are circular fingerprints encoding a local molecular environment around each atom up to a specified radius. This implementation closely follows the RDKit algorithm.\n\nFields\n\nradius::Int: The maximum number of bonds to traverse from each atom (default: 2)\n\nType Parameters\n\nN: The size of the fingerprint bit vector\n\nExamples\n\n# Create ECFP4 (radius=2) with 2048 bits\nfp_calc = ECFP{2048}(2)\n\n# Create ECFP6 (radius=3) with 1024 bits\nfp_calc = ECFP{1024}(3)\n\nReferences\n\nRogers, D., & Hahn, M. (2010). Extended-connectivity fingerprints. Journal of Chemical Information and Modeling, 50(5), 742-754.\n\n\n\n\n\n","category":"type"},{"location":"#MolecularFingerprints.MHFP","page":"Home","title":"MolecularFingerprints.MHFP","text":"MHFP\n\nType for MHFP fingerprint calculators. Contains settings and parameters for  MHFP fingerprint generation.\n\nThe MHFP fingerprint is a vector of UInt32's, calculated for a given molecule by:\n\ngenerating the \"molecular shingling\" of the molecule, which is a set of strings,   containing:\nThe SMILES strings of all rings in the smallest set of smallest rings (sssr)   of the molecule (optional, corresponds to setting rings=true in the MHFP   calculator object),\nThe SMILES strings of the circular substructures of radii min_radius:radius around  each heavy atom of the molecule. Note: if min_radius=0, the corresponding   substructures are just the atoms themselves. \nHashing the molecular shingling, which consists of:\nConverting each string to a 32-bit integer using SHA1 (and only using the first 32  bits of the hashed result)\nApplying the MinHash scheme to the set of 32-bit integers in order to generate the   final fingerprint. The exact formula is given in the original authors paper, but  we note here that it takes a vector of 32-bit integers as input, and is furthermore  dependent on two vectors a and b, each of a given length k, which is also the length  of the resulting fingerprint vector. The two vectors are sampled at random, but  must be the same for comparable fingerprints. Note: in the fields of MHFP objects,  the vectors a, b and their length k are named _permutations_a, _permutations_b   and n_permutations, respectively.\n\nThe avaliable parameters of the calculator object are:\n\nGiven as arguments to the constructor:\n\nradius::Int: The maximum radius of circular substructures around each heavy atom    of a molecule that are to be included in the fingerprint. Typical values are 2 or 3.\nmin_radius::Int: The minimum radius of circular substructures around each heavy atom   of a molecule that are to be considered. Will be 1 in most cases, however 0 is also    valid; in this case information about the heavy atoms of the molecules is included    explicitly in the fingerprints.\nrings::Int: If true, information about rings in the molecules is included in the    fingerprints explicitly.\n\nGiven as keyword arguments to the constructor:\n\nn_permutations::Int: length of the random vectors a and b which are used in    the hashing process. Also corresponds to the length of the final fingerprint.\nseed::Int: seed for the generation of the random vectors a and b which are used    in the hashing process. Must be the same for comparable fingerprints.\n\nAlso contains the fields _mersenne_prime, _max_hash, _permutations_a and  _permutations_b, which are internal and cannot be set explicitly. The first two are constants, and the second two are random vectors which are generated  automatically based on the given seed.\n\n\n\n\n\n","category":"type"},{"location":"#MolecularFingerprints.MorganAtomEnv","page":"Home","title":"MolecularFingerprints.MorganAtomEnv","text":"MorganAtomEnv\n\nInternal structure representing a Morgan atom environment.\n\nStores the hash code, atom identifier (index), and layer/radius for each atomic environment encountered during ECFP fingerprint generation.\n\nFields\n\ncode::UInt32: Hash code representing the atomic environment\natom_id::Int: Identifier of the central atom\nlayer::Int: Radius/layer at which this environment was computed\n\n\n\n\n\n","category":"type"},{"location":"#Base.isless-Tuple{MolecularFingerprints.AccumTuple, MolecularFingerprints.AccumTuple}","page":"Home","title":"Base.isless","text":"Base.isless(a::AccumTuple, b::AccumTuple)\n\nDefine ordering for AccumTuple objects to match RDKit's sorting behavior.\n\nCompares AccumTuples by first checking the bit vectors in reverse order (matching boost::dynamic_bitset comparison), then by invariant value, then by atom index.\n\nArguments\n\na::AccumTuple: First tuple to compare\nb::AccumTuple: Second tuple to compare\n\nReturns\n\nBool: true if a < b according to the defined ordering\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.ecfp_atom_invariant-Tuple{AbstractString}","page":"Home","title":"MolecularFingerprints.ecfp_atom_invariant","text":"ecfp_atom_invariant(smiles::AbstractString)\necfp_atom_invariant(mol::AbstractMolGraph)\necfp_atom_invariant(mol::AbstractMolGraph, atom_index)\n\nCalculate atomic invariants for ECFP fingerprint generation.\n\nThe atomic invariants are properties of an atom that don't depend on initial atom numbering, based on the Daylight atomic invariants. This implementation follows the RDKit approach.\n\nArguments\n\nsmiles::AbstractString: SMILES string representation of a molecule\nmol::AbstractMolGraph: Molecular graph structure\natom_index: Index of the specific atom to compute invariants for. If not specified, invariants for all atoms are computed and returned\n\nReturns\n\nFor single atom: Vector{UInt32} containing the invariant components\nFor all atoms: Vector{Vector{UInt32}} with invariants for each atom\n\nInvariant Components\n\nThe computed invariants include (in order):\n\nAtomic number\nTotal degree (number of neighbors including implicit hydrogens)\nTotal number of hydrogens (implicit + explicit)\nAtomic charge\nDelta mass (difference from standard isotope mass)\nRing membership indicator (1 if atom is in a ring, omitted otherwise)\n\nReferences\n\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/FingerprintUtil.cpp#L244\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.ecfp_hash-Tuple{Vector{UInt32}}","page":"Home","title":"MolecularFingerprints.ecfp_hash","text":"ecfp_hash(v::Vector{UInt32})\n\nGenerate a hash value from a vector of UInt32 values.\n\nIteratively combines all values in the vector using the ECFP hash combining algorithm to produce a single hash value representing the entire vector.\n\nArguments\n\nv::Vector{UInt32}: Vector of values to hash\n\nReturns\n\nUInt32: Hash value representing the input vector\n\nReferences\n\nBoost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/RDGeneral/hash/hash.hpp\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.ecfp_hash_combine-Tuple{UInt32, UInt32}","page":"Home","title":"MolecularFingerprints.ecfp_hash_combine","text":"ecfp_hash_combine(seed::UInt32, value::UInt32)\n\nCombine two hash values using the boost hash_combine algorithm.\n\nThis function implements the hash combining strategy used in RDKit's ECFP implementation, which is based on the boost C++ library's hash_combine function.\n\nArguments\n\nseed::UInt32: Current hash seed value\nvalue::UInt32: New value to combine into the hash\n\nReturns\n\nUInt32: Combined hash value\n\nReferences\n\nBoost hash implementation, as provided by RDKit: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/RDGeneral/hash/hash.hpp\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, MHFP}","page":"Home","title":"MolecularFingerprints.fingerprint","text":"fingerprint(mol::MolGraph, calc::MHFP)\n\nCalculates the MHFP fingerprint of the given molecule and returns it as a vector of UInt32's\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.fingerprint-Tuple{MolecularGraph.MolGraph, TopologicalTorsion}","page":"Home","title":"MolecularFingerprints.fingerprint","text":"fingerprint(mol::MolGraph, calc::TopologicalTorsion)\n\nReturns a topological torsion fingerprint as an integer vector for the molecule belonging to mol.  This function calls function which computes the Topological Torsion fingerprint based on the molecular structure using paths of length pathLength.\n\nArguments\n\nmol::MolGraph: the molecule for which to calculate the fingerprint\ncalc::TopologicalTorsion: struct containing parameters for fingerprint computation, which is just the path length.   must be at least 2\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.fingerprint-Tuple{String, AbstractCalculator}","page":"Home","title":"MolecularFingerprints.fingerprint","text":"fingerprint(smiles::String, calc::AbstractCalculator)\n\nCalculates the fingerprint for a single SMILES string using the specified calculator.\n\nReturns the fingerprint.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.fingerprint-Tuple{Vector{String}, AbstractCalculator}","page":"Home","title":"MolecularFingerprints.fingerprint","text":"fingerprint(smiles_list::Vector{String}, calc::AbstractCalculator)\n\nCalculates the fingerprint for a list of SMILES strings using the specified calculator.\n\nUses parallelization over input vector.\n\nReturns a vector of fingerprints.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.fingerprint-Union{Tuple{N}, Tuple{MolecularGraph.MolGraph, ECFP{N}}} where N","page":"Home","title":"MolecularFingerprints.fingerprint","text":"fingerprint(mol::MolGraph, calc::ECFP{N}) where N\n\nGenerate an ECFP (Extended-Connectivity Fingerprint) for a molecule.\n\nThis function implements the Morgan/ECFP algorithm as described in the original paper and matching the RDKit implementation. It generates circular fingerprints by iteratively expanding atomic neighborhoods up to the specified radius.\n\nAlgorithm Overview\n\nCompute initial atom invariants (layer 0)\nFor each layer up to the specified radius:\nExpand atomic neighborhoods by one bond\nHash neighborhood information to create new invariants\nDetect and eliminate duplicate neighborhoods\nStore unique atomic environments\nMap all environment hashes to bit positions in the fingerprint\n\nArguments\n\nmol::MolGraph: Input molecular graph\ncalc::ECFP{N}: ECFP calculator specifying radius and fingerprint size\n\nReturns\n\nBitVector: Binary fingerprint of length N with bits set for detected molecular features\n\nExamples\n\nmol = smilestomol(\"CCO\")  # Ethanol\nfp_calc = ECFP{2048}(2)   # ECFP4 with 2048 bits\nfp = fingerprint(mol, fp_calc)\n\nReferences\n\nRogers, D., & Hahn, M. (2010). Extended-connectivity fingerprints. J. Chem. Inf. Model., 50(5), 742-754.\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L257\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.getAtomCode-Tuple{Int64, Int64, Int64}","page":"Home","title":"MolecularFingerprints.getAtomCode","text":"getAtomCode(degree::Int, piBond::Int, atomicNumber::Int)\n\nCalculates an integer for an atom of a molecule from number of non-hydrogen branches, number of pi bonds and atomic number\n\nArguments\n\ndegree::Int: number of non-hydrogen branches\npiBond::Int: number of pi bonds\natomicNumber::Int: atomic number\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.getPathsOfLengthN-Tuple{MolecularGraph.MolGraph, Int64}","page":"Home","title":"MolecularFingerprints.getPathsOfLengthN","text":"getPathsOfLengthN(mol::MolGraph, N::Int)\n\nReturns a list of all simple paths of length N and cycles of length N - 1 in the Molecular Graph.\n\nArguments\n\nmol::MolGraph: the molecule from which to extract the walks\nN::Int: length of the walks, meaning number of vertices in walk\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.getTTFPCode-Tuple{Vector}","page":"Home","title":"MolecularFingerprints.getTTFPCode","text":"getTTFPCode(pathCodes::Vector)\n\nCalculates an integer from a number calculated from the atom codes of a path which will serve  as an index for which the fingerprint will be increased by 1.\n\nArguments\n\npathCodes::Vector: contains a code generated from the atom codes of molecules of a path\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.getTopologicalTorsionFP-Tuple{MolecularGraph.MolGraph, Int64}","page":"Home","title":"MolecularFingerprints.getTopologicalTorsionFP","text":"getTopologicalTorsionFP(mol::MolGraph, pathLength::Int)\n\nReturns the Topological Torsion Fingerprint of a molecule as a sparse Int Vector. This function loops over all simple paths of length pathLength and all cycles of length pathLength - 1 of the molecular graph,  and gets a number for each atom in a path, an \"Atom Code\" from which a sparse IntVector is calculated.\n\nArguments\n\nmol::MolGraph: the molecule for which to calculate the fingerprint\npathLength::Int: length of walks from molecular graph used to calculated fingerprint\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.get_atom_invariants-Tuple{MolecularGraph.MolGraph}","page":"Home","title":"MolecularFingerprints.get_atom_invariants","text":"get_atom_invariants(mol::MolGraph)\n\nCompute hashed atom invariants for all atoms in a molecule.\n\nArguments\n\nmol::MolGraph: Input molecular graph\n\nReturns\n\nVector{UInt32}: Hashed invariant values for each atom\n\nReferences\n\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L42\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.get_bond_invariants-Tuple{MolecularGraph.MolGraph}","page":"Home","title":"MolecularFingerprints.get_bond_invariants","text":"get_bond_invariants(mol::MolGraph)\n\nCompute bond type invariants for all bonds in a molecule.\n\nArguments\n\nmol::MolGraph: Input molecular graph\n\nReturns\n\nVector{UInt32}: Bond type codes for each bond in the molecule\n\nKnown Issue\n\nThe edge properties provided by MolecularGraph.jl are not in the same order as in RDKit. This results in different hashes and, ultimately, in different fingerprints for larger molecules compared to RDKit. As this would require rework on the smilestomol algorithm provided by MolecularGraph.jl, a fix for this issue is currently not in scope of this project.\n\nReferences\n\nRDKit implementation: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Fingerprints/MorganGenerator.cpp#L126\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.mhfp_hash_from_molecular_shingling-Tuple{Vector{String}, MHFP}","page":"Home","title":"MolecularFingerprints.mhfp_hash_from_molecular_shingling","text":"mhfp_hash_from_molecular_shingling(shingling::Vector{String}, calc::MHFP)\n\nCalculate the MinHash values from a given Molecular shingling.\n\nThe given calculator contains parameters such as the length of the random vectors a , b that are used in the hashing scheme, as well as the seed used when generating them. The algorithm is described in more detail in the original authors paper.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.mhfp_shingling_from_mol-Tuple{MolecularGraph.MolGraph, MHFP}","page":"Home","title":"MolecularFingerprints.mhfp_shingling_from_mol","text":"mhfp_shingling_from_mol(\n    mol::MolGraph,\n    calc::MHFP)\n\nCalculate the \"molecular shingling\" of a given molecule.\n\nA molecular shingling is a vector of \"SMILES\"-strings, calculated from the ring  structures and atom types of the molecule (optional), and the circular substructures  around each heavy (=non-hydrogen) atom of the molecule.\n\nArguments\n\nmol::MolGraph: the molecule for which to calculate the shingling.\ncalc::MHFP: fingeprint \"calculator\" object, containing the relevant parameters for the    fingerprint calculation, e.g., the radii of the circular substructures to be considered   and whether to include ring information explicitly in the fingerprints\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.rdkit_bond_type-Tuple{MolecularGraph.SMILESBond}","page":"Home","title":"MolecularFingerprints.rdkit_bond_type","text":"rdkit_bond_type(bond::SMILESBond)\n\nConvert a SMILES bond to RDKit's bond type encoding.\n\nMaps bond properties to integer codes matching RDKit's bond type enumeration.\n\nArguments\n\nbond::SMILESBond: Input bond object\n\nReturns\n\nInt: Bond type code (1-6 for single to hextuple, 12 for aromatic, 20 for other, 21 for zero)\n\nKnown Issues\n\nDue to differences in the internal representation of bonds within MolecularGraph.jl, we currently only support the most common bond types (1 to 6).\n\nReferences\n\nRDKit bond types: https://github.com/rdkit/rdkit/blob/Release202509_4/Code/GraphMol/Bond.h#L55\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.smiles_from_atoms-Tuple{MolecularGraph.MolGraph}","page":"Home","title":"MolecularFingerprints.smiles_from_atoms","text":"smiles_from_atoms(mol::MolGraph)\n\nReturn vector containing SMILES strings of all atoms of the given molecule.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.smiles_from_circular_substructures-Tuple{MolecularGraph.MolGraph, Int64, Int64}","page":"Home","title":"MolecularFingerprints.smiles_from_circular_substructures","text":"smiles_from_circular_substructures(\n    mol::MolGraph,\n    radius::Int,\n    min_radius::Int)\n\nReturn vector of SMILES strings of circular substructures around all atoms of a molecule.\n\nFor each atom of the given molecule, extract the substructures of radii min_radius to radius, and generate their corresponding SMILES strings.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.smiles_from_rings-Tuple{MolecularGraph.MolGraph}","page":"Home","title":"MolecularFingerprints.smiles_from_rings","text":"smiles_from_rings(mol::MolGraph)\n\nReturn vector containing SMILES strings of all rings in the SSSR of the given molecule.\n\nSSSR stands for the smallest set of smallest rings of the molecule.\n\nNote: This function uses the function sssr from MolecularGraph.jl, which returns a \"true\" smallest set of smallest rings of the given molecule. However, in the original implementation of the mhfp algorithm, the \"symmetrisized sssr\" is used, which in some cases is non-minimal, i.e., contains an additional ring. The rdkit function to get the symmetrisized sssr is not available in MolecularGraph.jl or in RDKitMinimalLib, which is why the standard sssr is used. In most cases, this will not have any effect, but for some molecules, such as cubane, it  will.\n\n\n\n\n\n","category":"method"},{"location":"#MolecularFingerprints.tanimoto-Tuple{BitVector, BitVector}","page":"Home","title":"MolecularFingerprints.tanimoto","text":"tanimoto(a::BitVector, b::BitVector) -> Float64\n\nCalculate the Tanimoto similarity coefficient (Jaccard Index) between two fingerprints. Formula: c / (a + b - c) where c is intersection count.\n\n\n\n\n\n","category":"method"}]
}
